//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Substrate.NetApi;
using Substrate.NetApi.Model.Extrinsics;
using Substrate.NetApi.Model.Meta;
using Substrate.NetApi.Model.Types;
using Substrate.NetApi.Model.Types.Base;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;


namespace Hydration.NetApi.Generated.Storage
{
    
    
    /// <summary>
    /// >> LBPStorage
    /// </summary>
    public sealed class LBPStorage
    {
        
        // Substrate client for the storage calls.
        private SubstrateClientExt _client;
        
        /// <summary>
        /// >> LBPStorage Constructor
        /// </summary>
        public LBPStorage(SubstrateClientExt client)
        {
            this._client = client;
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("LBP", "PoolData"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Hydration.NetApi.Generated.Model.sp_core.crypto.AccountId32), typeof(Hydration.NetApi.Generated.Model.pallet_lbp.Pool)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("LBP", "FeeCollectorWithAsset"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Hydration.NetApi.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Primitive.U32>), typeof(Substrate.NetApi.Model.Types.Primitive.Bool)));
        }
        
        /// <summary>
        /// >> PoolDataParams
        ///  Details of a pool.
        /// </summary>
        public static string PoolDataParams(Hydration.NetApi.Generated.Model.sp_core.crypto.AccountId32 key)
        {
            return RequestGenerator.GetStorage("LBP", "PoolData", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> PoolDataDefault
        /// Default value as hex string
        /// </summary>
        public static string PoolDataDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> PoolData
        ///  Details of a pool.
        /// </summary>
        public async Task<Hydration.NetApi.Generated.Model.pallet_lbp.Pool> PoolData(Hydration.NetApi.Generated.Model.sp_core.crypto.AccountId32 key, string blockhash, CancellationToken token)
        {
            string parameters = LBPStorage.PoolDataParams(key);
            var result = await _client.GetStorageAsync<Hydration.NetApi.Generated.Model.pallet_lbp.Pool>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> FeeCollectorWithAssetParams
        ///  Storage used for tracking existing fee collectors
        ///  Not more than one fee collector per asset possible
        /// </summary>
        public static string FeeCollectorWithAssetParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Hydration.NetApi.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Primitive.U32> key)
        {
            return RequestGenerator.GetStorage("LBP", "FeeCollectorWithAsset", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, key.Value);
        }
        
        /// <summary>
        /// >> FeeCollectorWithAssetDefault
        /// Default value as hex string
        /// </summary>
        public static string FeeCollectorWithAssetDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> FeeCollectorWithAsset
        ///  Storage used for tracking existing fee collectors
        ///  Not more than one fee collector per asset possible
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.Bool> FeeCollectorWithAsset(Substrate.NetApi.Model.Types.Base.BaseTuple<Hydration.NetApi.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Primitive.U32> key, string blockhash, CancellationToken token)
        {
            string parameters = LBPStorage.FeeCollectorWithAssetParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.Bool>(parameters, blockhash, token);
            return result;
        }
    }
    
    /// <summary>
    /// >> LBPCalls
    /// </summary>
    public sealed class LBPCalls
    {
        
        /// <summary>
        /// >> create_pool
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method CreatePool(Hydration.NetApi.Generated.Model.sp_core.crypto.AccountId32 pool_owner, Substrate.NetApi.Model.Types.Primitive.U32 asset_a, Substrate.NetApi.Model.Types.Primitive.U128 asset_a_amount, Substrate.NetApi.Model.Types.Primitive.U32 asset_b, Substrate.NetApi.Model.Types.Primitive.U128 asset_b_amount, Substrate.NetApi.Model.Types.Primitive.U32 initial_weight, Substrate.NetApi.Model.Types.Primitive.U32 final_weight, Hydration.NetApi.Generated.Model.pallet_lbp.EnumWeightCurveType weight_curve, Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32> fee, Hydration.NetApi.Generated.Model.sp_core.crypto.AccountId32 fee_collector, Substrate.NetApi.Model.Types.Primitive.U128 repay_target)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(pool_owner.Encode());
            byteArray.AddRange(asset_a.Encode());
            byteArray.AddRange(asset_a_amount.Encode());
            byteArray.AddRange(asset_b.Encode());
            byteArray.AddRange(asset_b_amount.Encode());
            byteArray.AddRange(initial_weight.Encode());
            byteArray.AddRange(final_weight.Encode());
            byteArray.AddRange(weight_curve.Encode());
            byteArray.AddRange(fee.Encode());
            byteArray.AddRange(fee_collector.Encode());
            byteArray.AddRange(repay_target.Encode());
            return new Method(73, "LBP", 0, "create_pool", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> update_pool_data
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method UpdatePoolData(Hydration.NetApi.Generated.Model.sp_core.crypto.AccountId32 pool_id, Substrate.NetApi.Model.Types.Base.BaseOpt<Hydration.NetApi.Generated.Model.sp_core.crypto.AccountId32> pool_owner, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U32> start, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U32> end, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U32> initial_weight, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U32> final_weight, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>> fee, Substrate.NetApi.Model.Types.Base.BaseOpt<Hydration.NetApi.Generated.Model.sp_core.crypto.AccountId32> fee_collector, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U128> repay_target)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(pool_id.Encode());
            byteArray.AddRange(pool_owner.Encode());
            byteArray.AddRange(start.Encode());
            byteArray.AddRange(end.Encode());
            byteArray.AddRange(initial_weight.Encode());
            byteArray.AddRange(final_weight.Encode());
            byteArray.AddRange(fee.Encode());
            byteArray.AddRange(fee_collector.Encode());
            byteArray.AddRange(repay_target.Encode());
            return new Method(73, "LBP", 1, "update_pool_data", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> add_liquidity
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method AddLiquidity(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U128> amount_a, Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U128> amount_b)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(amount_a.Encode());
            byteArray.AddRange(amount_b.Encode());
            return new Method(73, "LBP", 2, "add_liquidity", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> remove_liquidity
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method RemoveLiquidity(Hydration.NetApi.Generated.Model.sp_core.crypto.AccountId32 pool_id)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(pool_id.Encode());
            return new Method(73, "LBP", 3, "remove_liquidity", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> sell
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method Sell(Substrate.NetApi.Model.Types.Primitive.U32 asset_in, Substrate.NetApi.Model.Types.Primitive.U32 asset_out, Substrate.NetApi.Model.Types.Primitive.U128 amount, Substrate.NetApi.Model.Types.Primitive.U128 max_limit)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(asset_in.Encode());
            byteArray.AddRange(asset_out.Encode());
            byteArray.AddRange(amount.Encode());
            byteArray.AddRange(max_limit.Encode());
            return new Method(73, "LBP", 4, "sell", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> buy
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method Buy(Substrate.NetApi.Model.Types.Primitive.U32 asset_out, Substrate.NetApi.Model.Types.Primitive.U32 asset_in, Substrate.NetApi.Model.Types.Primitive.U128 amount, Substrate.NetApi.Model.Types.Primitive.U128 max_limit)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(asset_out.Encode());
            byteArray.AddRange(asset_in.Encode());
            byteArray.AddRange(amount.Encode());
            byteArray.AddRange(max_limit.Encode());
            return new Method(73, "LBP", 5, "buy", byteArray.ToArray());
        }
    }
    
    /// <summary>
    /// >> LBPConstants
    /// </summary>
    public sealed class LBPConstants
    {
        
        /// <summary>
        /// >> MinTradingLimit
        ///  Minimum trading limit, sole purpose of this is to keep the math working
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U128 MinTradingLimit()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U128();
            result.Create("0xE8030000000000000000000000000000");
            return result;
        }
        
        /// <summary>
        /// >> MinPoolLiquidity
        ///  Minimum pool liquidity, sole purpose of this is to keep the math working
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U128 MinPoolLiquidity()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U128();
            result.Create("0x40420F00000000000000000000000000");
            return result;
        }
        
        /// <summary>
        /// >> MaxInRatio
        ///  Max fraction of pool to sell in single transaction
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U128 MaxInRatio()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U128();
            result.Create("0x03000000000000000000000000000000");
            return result;
        }
        
        /// <summary>
        /// >> MaxOutRatio
        ///  Max fraction of pool to buy in single transaction
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U128 MaxOutRatio()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U128();
            result.Create("0x03000000000000000000000000000000");
            return result;
        }
        
        /// <summary>
        /// >> repay_fee
        /// </summary>
        public Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32> repay_fee()
        {
            var result = new Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>();
            result.Create("0x020000000A000000");
            return result;
        }
    }
    
    /// <summary>
    /// >> LBPErrors
    /// </summary>
    public enum LBPErrors
    {
        
        /// <summary>
        /// >> CannotCreatePoolWithSameAssets
        /// Pool assets can not be the same
        /// </summary>
        CannotCreatePoolWithSameAssets,
        
        /// <summary>
        /// >> NotOwner
        /// Account is not a pool owner
        /// </summary>
        NotOwner,
        
        /// <summary>
        /// >> SaleStarted
        /// Sale already started
        /// </summary>
        SaleStarted,
        
        /// <summary>
        /// >> SaleNotEnded
        /// Sale is still in progress
        /// </summary>
        SaleNotEnded,
        
        /// <summary>
        /// >> SaleIsNotRunning
        /// Sale is not running
        /// </summary>
        SaleIsNotRunning,
        
        /// <summary>
        /// >> MaxSaleDurationExceeded
        /// Sale duration is too long
        /// </summary>
        MaxSaleDurationExceeded,
        
        /// <summary>
        /// >> CannotAddZeroLiquidity
        /// Liquidity being added should not be zero
        /// </summary>
        CannotAddZeroLiquidity,
        
        /// <summary>
        /// >> InsufficientAssetBalance
        /// Asset balance too low
        /// </summary>
        InsufficientAssetBalance,
        
        /// <summary>
        /// >> PoolNotFound
        /// Pool does not exist
        /// </summary>
        PoolNotFound,
        
        /// <summary>
        /// >> PoolAlreadyExists
        /// Pool has been already created
        /// </summary>
        PoolAlreadyExists,
        
        /// <summary>
        /// >> InvalidBlockRange
        /// Invalid block range
        /// </summary>
        InvalidBlockRange,
        
        /// <summary>
        /// >> WeightCalculationError
        /// Calculation error
        /// </summary>
        WeightCalculationError,
        
        /// <summary>
        /// >> InvalidWeight
        /// Weight set is out of range
        /// </summary>
        InvalidWeight,
        
        /// <summary>
        /// >> ZeroAmount
        /// Can not perform a trade with zero amount
        /// </summary>
        ZeroAmount,
        
        /// <summary>
        /// >> MaxInRatioExceeded
        /// Trade amount is too high
        /// </summary>
        MaxInRatioExceeded,
        
        /// <summary>
        /// >> MaxOutRatioExceeded
        /// Trade amount is too high
        /// </summary>
        MaxOutRatioExceeded,
        
        /// <summary>
        /// >> FeeAmountInvalid
        /// Invalid fee amount
        /// </summary>
        FeeAmountInvalid,
        
        /// <summary>
        /// >> TradingLimitReached
        /// Trading limit reached
        /// </summary>
        TradingLimitReached,
        
        /// <summary>
        /// >> Overflow
        /// An unexpected integer overflow occurred
        /// </summary>
        Overflow,
        
        /// <summary>
        /// >> NothingToUpdate
        /// Nothing to update
        /// </summary>
        NothingToUpdate,
        
        /// <summary>
        /// >> InsufficientLiquidity
        /// Liquidity has not reached the required minimum.
        /// </summary>
        InsufficientLiquidity,
        
        /// <summary>
        /// >> InsufficientTradingAmount
        /// Amount is less than minimum trading limit.
        /// </summary>
        InsufficientTradingAmount,
        
        /// <summary>
        /// >> FeeCollectorWithAssetAlreadyUsed
        /// Not more than one fee collector per asset id
        /// </summary>
        FeeCollectorWithAssetAlreadyUsed,
    }
}
