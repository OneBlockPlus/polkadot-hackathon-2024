//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Substrate.NetApi;
using Substrate.NetApi.Model.Extrinsics;
using Substrate.NetApi.Model.Meta;
using Substrate.NetApi.Model.Types;
using Substrate.NetApi.Model.Types.Base;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;


namespace Hydration.NetApi.Generated.Storage
{
    
    
    /// <summary>
    /// >> CircuitBreakerStorage
    /// </summary>
    public sealed class CircuitBreakerStorage
    {
        
        // Substrate client for the storage calls.
        private SubstrateClientExt _client;
        
        /// <summary>
        /// >> CircuitBreakerStorage Constructor
        /// </summary>
        public CircuitBreakerStorage(SubstrateClientExt client)
        {
            this._client = client;
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("CircuitBreaker", "TradeVolumeLimitPerAsset"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.NetApi.Model.Types.Primitive.U32), typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("CircuitBreaker", "AllowedTradeVolumeLimitPerAsset"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.NetApi.Model.Types.Primitive.U32), typeof(Hydration.NetApi.Generated.Model.pallet_circuit_breaker.TradeVolumeLimit)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("CircuitBreaker", "LiquidityAddLimitPerAsset"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.NetApi.Model.Types.Primitive.U32), typeof(Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>>)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("CircuitBreaker", "AllowedAddLiquidityAmountPerAsset"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.NetApi.Model.Types.Primitive.U32), typeof(Hydration.NetApi.Generated.Model.pallet_circuit_breaker.LiquidityLimit)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("CircuitBreaker", "LiquidityRemoveLimitPerAsset"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.NetApi.Model.Types.Primitive.U32), typeof(Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>>)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("CircuitBreaker", "AllowedRemoveLiquidityAmountPerAsset"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.NetApi.Model.Types.Primitive.U32), typeof(Hydration.NetApi.Generated.Model.pallet_circuit_breaker.LiquidityLimit)));
        }
        
        /// <summary>
        /// >> TradeVolumeLimitPerAssetParams
        ///  Trade volume limits of assets set by set_trade_volume_limit.
        ///  If not set, returns the default limit.
        /// </summary>
        public static string TradeVolumeLimitPerAssetParams(Substrate.NetApi.Model.Types.Primitive.U32 key)
        {
            return RequestGenerator.GetStorage("CircuitBreaker", "TradeVolumeLimitPerAsset", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> TradeVolumeLimitPerAssetDefault
        /// Default value as hex string
        /// </summary>
        public static string TradeVolumeLimitPerAssetDefault()
        {
            return "0x8813000010270000";
        }
        
        /// <summary>
        /// >> TradeVolumeLimitPerAsset
        ///  Trade volume limits of assets set by set_trade_volume_limit.
        ///  If not set, returns the default limit.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>> TradeVolumeLimitPerAsset(Substrate.NetApi.Model.Types.Primitive.U32 key, string blockhash, CancellationToken token)
        {
            string parameters = CircuitBreakerStorage.TradeVolumeLimitPerAssetParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> AllowedTradeVolumeLimitPerAssetParams
        ///  Trade volumes per asset
        /// </summary>
        public static string AllowedTradeVolumeLimitPerAssetParams(Substrate.NetApi.Model.Types.Primitive.U32 key)
        {
            return RequestGenerator.GetStorage("CircuitBreaker", "AllowedTradeVolumeLimitPerAsset", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> AllowedTradeVolumeLimitPerAssetDefault
        /// Default value as hex string
        /// </summary>
        public static string AllowedTradeVolumeLimitPerAssetDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> AllowedTradeVolumeLimitPerAsset
        ///  Trade volumes per asset
        /// </summary>
        public async Task<Hydration.NetApi.Generated.Model.pallet_circuit_breaker.TradeVolumeLimit> AllowedTradeVolumeLimitPerAsset(Substrate.NetApi.Model.Types.Primitive.U32 key, string blockhash, CancellationToken token)
        {
            string parameters = CircuitBreakerStorage.AllowedTradeVolumeLimitPerAssetParams(key);
            var result = await _client.GetStorageAsync<Hydration.NetApi.Generated.Model.pallet_circuit_breaker.TradeVolumeLimit>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> LiquidityAddLimitPerAssetParams
        ///  Liquidity limits of assets for adding liquidity.
        ///  If not set, returns the default limit.
        /// </summary>
        public static string LiquidityAddLimitPerAssetParams(Substrate.NetApi.Model.Types.Primitive.U32 key)
        {
            return RequestGenerator.GetStorage("CircuitBreaker", "LiquidityAddLimitPerAsset", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> LiquidityAddLimitPerAssetDefault
        /// Default value as hex string
        /// </summary>
        public static string LiquidityAddLimitPerAssetDefault()
        {
            return "0x01F401000010270000";
        }
        
        /// <summary>
        /// >> LiquidityAddLimitPerAsset
        ///  Liquidity limits of assets for adding liquidity.
        ///  If not set, returns the default limit.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>>> LiquidityAddLimitPerAsset(Substrate.NetApi.Model.Types.Primitive.U32 key, string blockhash, CancellationToken token)
        {
            string parameters = CircuitBreakerStorage.LiquidityAddLimitPerAssetParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>>>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> AllowedAddLiquidityAmountPerAssetParams
        ///  Add liquidity volumes per asset
        /// </summary>
        public static string AllowedAddLiquidityAmountPerAssetParams(Substrate.NetApi.Model.Types.Primitive.U32 key)
        {
            return RequestGenerator.GetStorage("CircuitBreaker", "AllowedAddLiquidityAmountPerAsset", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> AllowedAddLiquidityAmountPerAssetDefault
        /// Default value as hex string
        /// </summary>
        public static string AllowedAddLiquidityAmountPerAssetDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> AllowedAddLiquidityAmountPerAsset
        ///  Add liquidity volumes per asset
        /// </summary>
        public async Task<Hydration.NetApi.Generated.Model.pallet_circuit_breaker.LiquidityLimit> AllowedAddLiquidityAmountPerAsset(Substrate.NetApi.Model.Types.Primitive.U32 key, string blockhash, CancellationToken token)
        {
            string parameters = CircuitBreakerStorage.AllowedAddLiquidityAmountPerAssetParams(key);
            var result = await _client.GetStorageAsync<Hydration.NetApi.Generated.Model.pallet_circuit_breaker.LiquidityLimit>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> LiquidityRemoveLimitPerAssetParams
        ///  Liquidity limits of assets for removing liquidity.
        ///  If not set, returns the default limit.
        /// </summary>
        public static string LiquidityRemoveLimitPerAssetParams(Substrate.NetApi.Model.Types.Primitive.U32 key)
        {
            return RequestGenerator.GetStorage("CircuitBreaker", "LiquidityRemoveLimitPerAsset", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> LiquidityRemoveLimitPerAssetDefault
        /// Default value as hex string
        /// </summary>
        public static string LiquidityRemoveLimitPerAssetDefault()
        {
            return "0x01F401000010270000";
        }
        
        /// <summary>
        /// >> LiquidityRemoveLimitPerAsset
        ///  Liquidity limits of assets for removing liquidity.
        ///  If not set, returns the default limit.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>>> LiquidityRemoveLimitPerAsset(Substrate.NetApi.Model.Types.Primitive.U32 key, string blockhash, CancellationToken token)
        {
            string parameters = CircuitBreakerStorage.LiquidityRemoveLimitPerAssetParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>>>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> AllowedRemoveLiquidityAmountPerAssetParams
        ///  Remove liquidity volumes per asset
        /// </summary>
        public static string AllowedRemoveLiquidityAmountPerAssetParams(Substrate.NetApi.Model.Types.Primitive.U32 key)
        {
            return RequestGenerator.GetStorage("CircuitBreaker", "AllowedRemoveLiquidityAmountPerAsset", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> AllowedRemoveLiquidityAmountPerAssetDefault
        /// Default value as hex string
        /// </summary>
        public static string AllowedRemoveLiquidityAmountPerAssetDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> AllowedRemoveLiquidityAmountPerAsset
        ///  Remove liquidity volumes per asset
        /// </summary>
        public async Task<Hydration.NetApi.Generated.Model.pallet_circuit_breaker.LiquidityLimit> AllowedRemoveLiquidityAmountPerAsset(Substrate.NetApi.Model.Types.Primitive.U32 key, string blockhash, CancellationToken token)
        {
            string parameters = CircuitBreakerStorage.AllowedRemoveLiquidityAmountPerAssetParams(key);
            var result = await _client.GetStorageAsync<Hydration.NetApi.Generated.Model.pallet_circuit_breaker.LiquidityLimit>(parameters, blockhash, token);
            return result;
        }
    }
    
    /// <summary>
    /// >> CircuitBreakerCalls
    /// </summary>
    public sealed class CircuitBreakerCalls
    {
        
        /// <summary>
        /// >> set_trade_volume_limit
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method SetTradeVolumeLimit(Substrate.NetApi.Model.Types.Primitive.U32 asset_id, Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32> trade_volume_limit)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(asset_id.Encode());
            byteArray.AddRange(trade_volume_limit.Encode());
            return new Method(65, "CircuitBreaker", 0, "set_trade_volume_limit", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_add_liquidity_limit
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method SetAddLiquidityLimit(Substrate.NetApi.Model.Types.Primitive.U32 asset_id, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>> liquidity_limit)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(asset_id.Encode());
            byteArray.AddRange(liquidity_limit.Encode());
            return new Method(65, "CircuitBreaker", 1, "set_add_liquidity_limit", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_remove_liquidity_limit
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method SetRemoveLiquidityLimit(Substrate.NetApi.Model.Types.Primitive.U32 asset_id, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>> liquidity_limit)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(asset_id.Encode());
            byteArray.AddRange(liquidity_limit.Encode());
            return new Method(65, "CircuitBreaker", 2, "set_remove_liquidity_limit", byteArray.ToArray());
        }
    }
    
    /// <summary>
    /// >> CircuitBreakerConstants
    /// </summary>
    public sealed class CircuitBreakerConstants
    {
        
        /// <summary>
        /// >> DefaultMaxNetTradeVolumeLimitPerBlock
        ///  The maximum percentage of a pool's liquidity that can be traded in a block.
        ///  Represented as a non-zero fraction (nominator, denominator) with the max value being 10_000.
        /// </summary>
        public Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32> DefaultMaxNetTradeVolumeLimitPerBlock()
        {
            var result = new Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>();
            result.Create("0x8813000010270000");
            return result;
        }
        
        /// <summary>
        /// >> DefaultMaxAddLiquidityLimitPerBlock
        ///  The maximum percentage of a pool's liquidity that can be added in a block.
        ///  Represented as an optional non-zero fraction (nominator, denominator) with the max value being 10_000.
        ///  If set to None, the limits are not enforced.
        /// </summary>
        public Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>> DefaultMaxAddLiquidityLimitPerBlock()
        {
            var result = new Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>>();
            result.Create("0x01F401000010270000");
            return result;
        }
        
        /// <summary>
        /// >> DefaultMaxRemoveLiquidityLimitPerBlock
        ///  The maximum percentage of a pool's liquidity that can be removed in a block.
        ///  Represented as an optional non-zero fraction (nominator, denominator) with the max value being 10_000.
        ///  If set to None, the limits are not enforced.
        /// </summary>
        public Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>> DefaultMaxRemoveLiquidityLimitPerBlock()
        {
            var result = new Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>>();
            result.Create("0x01F401000010270000");
            return result;
        }
    }
    
    /// <summary>
    /// >> CircuitBreakerErrors
    /// </summary>
    public enum CircuitBreakerErrors
    {
        
        /// <summary>
        /// >> InvalidLimitValue
        /// Invalid value for a limit. Limit must be non-zero.
        /// </summary>
        InvalidLimitValue,
        
        /// <summary>
        /// >> LiquidityLimitNotStoredForAsset
        /// Allowed liquidity limit is not stored for asset
        /// </summary>
        LiquidityLimitNotStoredForAsset,
        
        /// <summary>
        /// >> TokenOutflowLimitReached
        /// Token trade outflow per block has been reached
        /// </summary>
        TokenOutflowLimitReached,
        
        /// <summary>
        /// >> TokenInfluxLimitReached
        /// Token trade influx per block has been reached
        /// </summary>
        TokenInfluxLimitReached,
        
        /// <summary>
        /// >> MaxLiquidityLimitPerBlockReached
        /// Maximum pool's liquidity limit per block has been reached
        /// </summary>
        MaxLiquidityLimitPerBlockReached,
        
        /// <summary>
        /// >> NotAllowed
        /// Asset is not allowed to have a limit
        /// </summary>
        NotAllowed,
    }
}
