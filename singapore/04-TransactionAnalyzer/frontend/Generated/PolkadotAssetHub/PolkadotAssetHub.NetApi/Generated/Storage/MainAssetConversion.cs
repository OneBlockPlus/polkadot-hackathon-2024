//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Substrate.NetApi;
using Substrate.NetApi.Model.Extrinsics;
using Substrate.NetApi.Model.Meta;
using Substrate.NetApi.Model.Types;
using Substrate.NetApi.Model.Types.Base;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;


namespace PolkadotAssetHub.NetApi.Generated.Storage
{
    
    
    /// <summary>
    /// >> AssetConversionStorage
    /// </summary>
    public sealed class AssetConversionStorage
    {
        
        // Substrate client for the storage calls.
        private SubstrateClientExt _client;
        
        /// <summary>
        /// >> AssetConversionStorage Constructor
        /// </summary>
        public AssetConversionStorage(SubstrateClientExt client)
        {
            this._client = client;
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("AssetConversion", "Pools"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<PolkadotAssetHub.NetApi.Generated.Model.staging_xcm.v3.multilocation.MultiLocation, PolkadotAssetHub.NetApi.Generated.Model.staging_xcm.v3.multilocation.MultiLocation>), typeof(PolkadotAssetHub.NetApi.Generated.Model.pallet_asset_conversion.types.PoolInfo)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("AssetConversion", "NextPoolAssetId"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Primitive.U32)));
        }
        
        /// <summary>
        /// >> PoolsParams
        ///  Map from `PoolAssetId` to `PoolInfo`. This establishes whether a pool has been officially
        ///  created rather than people sending tokens directly to a pool's public account.
        /// </summary>
        public static string PoolsParams(Substrate.NetApi.Model.Types.Base.BaseTuple<PolkadotAssetHub.NetApi.Generated.Model.staging_xcm.v3.multilocation.MultiLocation, PolkadotAssetHub.NetApi.Generated.Model.staging_xcm.v3.multilocation.MultiLocation> key)
        {
            return RequestGenerator.GetStorage("AssetConversion", "Pools", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> PoolsDefault
        /// Default value as hex string
        /// </summary>
        public static string PoolsDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> Pools
        ///  Map from `PoolAssetId` to `PoolInfo`. This establishes whether a pool has been officially
        ///  created rather than people sending tokens directly to a pool's public account.
        /// </summary>
        public async Task<PolkadotAssetHub.NetApi.Generated.Model.pallet_asset_conversion.types.PoolInfo> Pools(Substrate.NetApi.Model.Types.Base.BaseTuple<PolkadotAssetHub.NetApi.Generated.Model.staging_xcm.v3.multilocation.MultiLocation, PolkadotAssetHub.NetApi.Generated.Model.staging_xcm.v3.multilocation.MultiLocation> key, string blockhash, CancellationToken token)
        {
            string parameters = AssetConversionStorage.PoolsParams(key);
            var result = await _client.GetStorageAsync<PolkadotAssetHub.NetApi.Generated.Model.pallet_asset_conversion.types.PoolInfo>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> NextPoolAssetIdParams
        ///  Stores the `PoolAssetId` that is going to be used for the next lp token.
        ///  This gets incremented whenever a new lp pool is created.
        /// </summary>
        public static string NextPoolAssetIdParams()
        {
            return RequestGenerator.GetStorage("AssetConversion", "NextPoolAssetId", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> NextPoolAssetIdDefault
        /// Default value as hex string
        /// </summary>
        public static string NextPoolAssetIdDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> NextPoolAssetId
        ///  Stores the `PoolAssetId` that is going to be used for the next lp token.
        ///  This gets incremented whenever a new lp pool is created.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U32> NextPoolAssetId(string blockhash, CancellationToken token)
        {
            string parameters = AssetConversionStorage.NextPoolAssetIdParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U32>(parameters, blockhash, token);
            return result;
        }
    }
    
    /// <summary>
    /// >> AssetConversionCalls
    /// </summary>
    public sealed class AssetConversionCalls
    {
        
        /// <summary>
        /// >> create_pool
        /// Pallet's callable functions.
        /// </summary>
        public static Method CreatePool(PolkadotAssetHub.NetApi.Generated.Model.staging_xcm.v3.multilocation.MultiLocation asset1, PolkadotAssetHub.NetApi.Generated.Model.staging_xcm.v3.multilocation.MultiLocation asset2)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(asset1.Encode());
            byteArray.AddRange(asset2.Encode());
            return new Method(55, "AssetConversion", 0, "create_pool", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> add_liquidity
        /// Pallet's callable functions.
        /// </summary>
        public static Method AddLiquidity(PolkadotAssetHub.NetApi.Generated.Model.staging_xcm.v3.multilocation.MultiLocation asset1, PolkadotAssetHub.NetApi.Generated.Model.staging_xcm.v3.multilocation.MultiLocation asset2, Substrate.NetApi.Model.Types.Primitive.U128 amount1_desired, Substrate.NetApi.Model.Types.Primitive.U128 amount2_desired, Substrate.NetApi.Model.Types.Primitive.U128 amount1_min, Substrate.NetApi.Model.Types.Primitive.U128 amount2_min, PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32 mint_to)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(asset1.Encode());
            byteArray.AddRange(asset2.Encode());
            byteArray.AddRange(amount1_desired.Encode());
            byteArray.AddRange(amount2_desired.Encode());
            byteArray.AddRange(amount1_min.Encode());
            byteArray.AddRange(amount2_min.Encode());
            byteArray.AddRange(mint_to.Encode());
            return new Method(55, "AssetConversion", 1, "add_liquidity", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> remove_liquidity
        /// Pallet's callable functions.
        /// </summary>
        public static Method RemoveLiquidity(PolkadotAssetHub.NetApi.Generated.Model.staging_xcm.v3.multilocation.MultiLocation asset1, PolkadotAssetHub.NetApi.Generated.Model.staging_xcm.v3.multilocation.MultiLocation asset2, Substrate.NetApi.Model.Types.Primitive.U128 lp_token_burn, Substrate.NetApi.Model.Types.Primitive.U128 amount1_min_receive, Substrate.NetApi.Model.Types.Primitive.U128 amount2_min_receive, PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32 withdraw_to)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(asset1.Encode());
            byteArray.AddRange(asset2.Encode());
            byteArray.AddRange(lp_token_burn.Encode());
            byteArray.AddRange(amount1_min_receive.Encode());
            byteArray.AddRange(amount2_min_receive.Encode());
            byteArray.AddRange(withdraw_to.Encode());
            return new Method(55, "AssetConversion", 2, "remove_liquidity", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> swap_exact_tokens_for_tokens
        /// Pallet's callable functions.
        /// </summary>
        public static Method SwapExactTokensForTokens(Substrate.NetApi.Model.Types.Base.BaseVec<PolkadotAssetHub.NetApi.Generated.Model.staging_xcm.v3.multilocation.MultiLocation> path, Substrate.NetApi.Model.Types.Primitive.U128 amount_in, Substrate.NetApi.Model.Types.Primitive.U128 amount_out_min, PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32 send_to, Substrate.NetApi.Model.Types.Primitive.Bool keep_alive)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(path.Encode());
            byteArray.AddRange(amount_in.Encode());
            byteArray.AddRange(amount_out_min.Encode());
            byteArray.AddRange(send_to.Encode());
            byteArray.AddRange(keep_alive.Encode());
            return new Method(55, "AssetConversion", 3, "swap_exact_tokens_for_tokens", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> swap_tokens_for_exact_tokens
        /// Pallet's callable functions.
        /// </summary>
        public static Method SwapTokensForExactTokens(Substrate.NetApi.Model.Types.Base.BaseVec<PolkadotAssetHub.NetApi.Generated.Model.staging_xcm.v3.multilocation.MultiLocation> path, Substrate.NetApi.Model.Types.Primitive.U128 amount_out, Substrate.NetApi.Model.Types.Primitive.U128 amount_in_max, PolkadotAssetHub.NetApi.Generated.Model.sp_core.crypto.AccountId32 send_to, Substrate.NetApi.Model.Types.Primitive.Bool keep_alive)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(path.Encode());
            byteArray.AddRange(amount_out.Encode());
            byteArray.AddRange(amount_in_max.Encode());
            byteArray.AddRange(send_to.Encode());
            byteArray.AddRange(keep_alive.Encode());
            return new Method(55, "AssetConversion", 4, "swap_tokens_for_exact_tokens", byteArray.ToArray());
        }
    }
    
    /// <summary>
    /// >> AssetConversionConstants
    /// </summary>
    public sealed class AssetConversionConstants
    {
        
        /// <summary>
        /// >> LPFee
        ///  A % the liquidity providers will take of every swap. Represents 10ths of a percent.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 LPFee()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x03000000");
            return result;
        }
        
        /// <summary>
        /// >> PoolSetupFee
        ///  A one-time fee to setup the pool.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U128 PoolSetupFee()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U128();
            result.Create("0x402D93EF000000000000000000000000");
            return result;
        }
        
        /// <summary>
        /// >> PoolSetupFeeAsset
        ///  Asset class from [`Config::Assets`] used to pay the [`Config::PoolSetupFee`].
        /// </summary>
        public PolkadotAssetHub.NetApi.Generated.Model.staging_xcm.v3.multilocation.MultiLocation PoolSetupFeeAsset()
        {
            var result = new PolkadotAssetHub.NetApi.Generated.Model.staging_xcm.v3.multilocation.MultiLocation();
            result.Create("0x0100");
            return result;
        }
        
        /// <summary>
        /// >> LiquidityWithdrawalFee
        ///  A fee to withdraw the liquidity.
        /// </summary>
        public PolkadotAssetHub.NetApi.Generated.Model.sp_arithmetic.per_things.Permill LiquidityWithdrawalFee()
        {
            var result = new PolkadotAssetHub.NetApi.Generated.Model.sp_arithmetic.per_things.Permill();
            result.Create("0x00000000");
            return result;
        }
        
        /// <summary>
        /// >> MintMinLiquidity
        ///  The minimum LP token amount that could be minted. Ameliorates rounding errors.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U128 MintMinLiquidity()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U128();
            result.Create("0x64000000000000000000000000000000");
            return result;
        }
        
        /// <summary>
        /// >> MaxSwapPathLength
        ///  The max number of hops in a swap.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 MaxSwapPathLength()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x03000000");
            return result;
        }
        
        /// <summary>
        /// >> PalletId
        ///  The pallet's id, used for deriving its sovereign account ID.
        /// </summary>
        public PolkadotAssetHub.NetApi.Generated.Model.frame_support.PalletId PalletId()
        {
            var result = new PolkadotAssetHub.NetApi.Generated.Model.frame_support.PalletId();
            result.Create("0x70792F6173636F6E");
            return result;
        }
    }
    
    /// <summary>
    /// >> AssetConversionErrors
    /// </summary>
    public enum AssetConversionErrors
    {
        
        /// <summary>
        /// >> InvalidAssetPair
        /// Provided asset pair is not supported for pool.
        /// </summary>
        InvalidAssetPair,
        
        /// <summary>
        /// >> PoolExists
        /// Pool already exists.
        /// </summary>
        PoolExists,
        
        /// <summary>
        /// >> WrongDesiredAmount
        /// Desired amount can't be zero.
        /// </summary>
        WrongDesiredAmount,
        
        /// <summary>
        /// >> AmountOneLessThanMinimal
        /// Provided amount should be greater than or equal to the existential deposit/asset's
        /// minimal amount.
        /// </summary>
        AmountOneLessThanMinimal,
        
        /// <summary>
        /// >> AmountTwoLessThanMinimal
        /// Provided amount should be greater than or equal to the existential deposit/asset's
        /// minimal amount.
        /// </summary>
        AmountTwoLessThanMinimal,
        
        /// <summary>
        /// >> ReserveLeftLessThanMinimal
        /// Reserve needs to always be greater than or equal to the existential deposit/asset's
        /// minimal amount.
        /// </summary>
        ReserveLeftLessThanMinimal,
        
        /// <summary>
        /// >> AmountOutTooHigh
        /// Desired amount can't be equal to the pool reserve.
        /// </summary>
        AmountOutTooHigh,
        
        /// <summary>
        /// >> PoolNotFound
        /// The pool doesn't exist.
        /// </summary>
        PoolNotFound,
        
        /// <summary>
        /// >> Overflow
        /// An overflow happened.
        /// </summary>
        Overflow,
        
        /// <summary>
        /// >> AssetOneDepositDidNotMeetMinimum
        /// The minimal amount requirement for the first token in the pair wasn't met.
        /// </summary>
        AssetOneDepositDidNotMeetMinimum,
        
        /// <summary>
        /// >> AssetTwoDepositDidNotMeetMinimum
        /// The minimal amount requirement for the second token in the pair wasn't met.
        /// </summary>
        AssetTwoDepositDidNotMeetMinimum,
        
        /// <summary>
        /// >> AssetOneWithdrawalDidNotMeetMinimum
        /// The minimal amount requirement for the first token in the pair wasn't met.
        /// </summary>
        AssetOneWithdrawalDidNotMeetMinimum,
        
        /// <summary>
        /// >> AssetTwoWithdrawalDidNotMeetMinimum
        /// The minimal amount requirement for the second token in the pair wasn't met.
        /// </summary>
        AssetTwoWithdrawalDidNotMeetMinimum,
        
        /// <summary>
        /// >> OptimalAmountLessThanDesired
        /// Optimal calculated amount is less than desired.
        /// </summary>
        OptimalAmountLessThanDesired,
        
        /// <summary>
        /// >> InsufficientLiquidityMinted
        /// Insufficient liquidity minted.
        /// </summary>
        InsufficientLiquidityMinted,
        
        /// <summary>
        /// >> ZeroLiquidity
        /// Requested liquidity can't be zero.
        /// </summary>
        ZeroLiquidity,
        
        /// <summary>
        /// >> ZeroAmount
        /// Amount can't be zero.
        /// </summary>
        ZeroAmount,
        
        /// <summary>
        /// >> ProvidedMinimumNotSufficientForSwap
        /// Calculated amount out is less than provided minimum amount.
        /// </summary>
        ProvidedMinimumNotSufficientForSwap,
        
        /// <summary>
        /// >> ProvidedMaximumNotSufficientForSwap
        /// Provided maximum amount is not sufficient for swap.
        /// </summary>
        ProvidedMaximumNotSufficientForSwap,
        
        /// <summary>
        /// >> InvalidPath
        /// The provided path must consists of 2 assets at least.
        /// </summary>
        InvalidPath,
        
        /// <summary>
        /// >> NonUniquePath
        /// The provided path must consists of unique assets.
        /// </summary>
        NonUniquePath,
        
        /// <summary>
        /// >> IncorrectPoolAssetId
        /// It was not possible to get or increment the Id of the pool.
        /// </summary>
        IncorrectPoolAssetId,
        
        /// <summary>
        /// >> BelowMinimum
        /// The destination account cannot exist with the swapped funds.
        /// </summary>
        BelowMinimum,
    }
}
