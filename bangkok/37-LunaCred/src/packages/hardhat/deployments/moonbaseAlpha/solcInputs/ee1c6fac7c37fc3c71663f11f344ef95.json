{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"./IAccessControl.sol\";\nimport {Context} from \"../utils/Context.sol\";\nimport {ERC165} from \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/LunaCred.sol": {
      "content": "//SPDX-License-Identifier: MIT\n// This is a PoC to use the staking precompile wrapper as a Solidity developer.\npragma solidity >=0.8.0;\n\nimport \"./StakingInterface.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"./SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\ncontract LunaCred is AccessControl {\n\n    using SafeMath for uint256;\n    \n    // Role definition for contract members\n    bytes32 public constant MEMBER = keccak256(\"MEMBER\");\n\n    // Possible states for the DAO to be in:\n    // COLLECTING: the DAO is collecting funds before creating a delegation once the minimum delegation stake has been reached\n    // STAKING: the DAO has an active delegation\n    // REVOKING: the DAO has scheduled a delegation revoke\n    // REVOKED: the scheduled revoke has been executed\n    enum daoState{ COLLECTING, STAKING, REVOKING, REVOKED }\n\n    // Current state that the DAO is in\n    daoState public currentState; \n\n    // Member stakes (doesnt include rewards, represents member shares)\n    mapping(address => uint256) public memberStakes;\n\n    //credbility points mapping for the stakers and the addresses\n    mapping(address => uint256) public credibilityPoints;\n    \n       mapping(address => mapping(address => uint256)) public stakedOnBehalfOf;\n\n    // Total Staking Pool (doesnt include rewards, represents total shares)\n    uint256 public totalStake;\n\n    // The ParachainStaking wrapper at the known pre-compile address. This will be used to make\n    // all calls to the underlying staking solution\n    ParachainStaking public staking;\n    \n    // Minimum Delegation Amount\n    uint256 public constant minDelegationStk = 1 ether;\n    // / Credibility points are 30% of staked amount\n    uint256 public constant CREDIBILITY_RATE = 30;\n    // Moonbeam Staking Precompile address\n    address public constant stakingPrecompileAddress = 0x0000000000000000000000000000000000000800;\n\n    // The collator that this DAO is currently nominating\n    address public target;\n\n    // Event for a member deposit\n    // event deposit(address indexed _from, uint _value);\n   event Deposit(address indexed from, address indexed recipient, uint256 value, uint256 credibilityAdded);\n\n    // Event for a member withdrawal\n    event withdrawal(address indexed _from, address indexed _to, uint _value);\n     event CredibilityUpdated(address indexed user, uint256 newCredibility);\n\n    // Initialize a new DelegationDao dedicated to delegating to the given collator target.\n    constructor(address _target, address admin) {\n        \n        //Sets the collator that this DAO nominating\n        target = _target;\n        \n        // Initializes Moonbeam's parachain staking precompile\n        staking = ParachainStaking(stakingPrecompileAddress);\n        \n        //Initializes Roles\n        // _setupRole(DEFAULT_ADMIN_ROLE, admin);\n        // _setupRole(MEMBER, admin);\n\n       // Grant the admin the default admin role\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n\n        // Grant the admin the MEMBER role\n        _grantRole(MEMBER, admin);\n        //Initialize the DAO state\n        currentState = daoState.COLLECTING;\n        \n    }\n\n    // Grant a user the role of admin\n    function grant_admin(address newAdmin)\n        public\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyRole(MEMBER)\n    {\n        grantRole(DEFAULT_ADMIN_ROLE, newAdmin);\n        grantRole(MEMBER, newAdmin);\n    }\n\n    // Grant a user membership\n    function grant_member(address newMember)\n        public\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        grantRole(MEMBER, newMember);\n    }\n\n    // Revoke a user membership\n    function remove_member(address payable exMember)\n        public\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        revokeRole(MEMBER, exMember);\n    }\n\n    // Increase member stake via a payable function and automatically stake the added amount if possible\n    // function add_stake() external payable onlyRole(MEMBER) {\n    //     if (currentState == daoState.STAKING ) {\n    //         // Sanity check\n    //         if(!staking.isDelegator(address(this))){\n    //              revert(\"The DAO is in an inconsistent state.\");\n    //         }\n    //         memberStakes[msg.sender] = memberStakes[msg.sender].add(msg.value);\n    //         totalStake = totalStake.add(msg.value);\n    //         emit deposit(msg.sender, msg.value);\n    //         staking.delegatorBondMore(target, msg.value);\n    //     }\n    //     else if  (currentState == daoState.COLLECTING ){\n    //         memberStakes[msg.sender] = memberStakes[msg.sender].add(msg.value);\n    //         totalStake = totalStake.add(msg.value);\n    //         emit deposit(msg.sender, msg.value);\n    //         if(totalStake < minDelegationStk){\n    //             return;\n    //         } else {\n    //             //initialiate the delegation and change the state          \n    //             staking.delegate(target, address(this).balance, staking.candidateDelegationCount(target), staking.delegatorDelegationCount(address(this)));\n    //             currentState = daoState.STAKING;\n    //         }\n    //     }\n    //     else {\n    //         revert(\"The DAO is not accepting new stakes in the current state.\");\n    //     }\n    // }\n\n// uint256 public constant CREDIBILITY_POINTS_RATE = 100; // 1 token = 100 points\n\n// Modify the add_stake function\n    function addStake(address recipient) external payable onlyRole(MEMBER) {\n        require(hasRole(MEMBER, recipient), \"Recipient must be a DAO member\");\n        \n        if (currentState == daoState.STAKING) {\n            require(staking.isDelegator(address(this)), \"DAO is in an inconsistent state\");\n            staking.delegatorBondMore(target, msg.value);\n        } else if (currentState == daoState.COLLECTING) {\n            if (address(this).balance >= minDelegationStk) {\n                staking.delegate(target, address(this).balance, staking.candidateDelegationCount(target), staking.delegatorDelegationCount(address(this)));\n                currentState = daoState.STAKING;\n            }\n        } else {\n            revert(\"DAO is not accepting new stakes\");\n        }\n        \n        memberStakes[msg.sender] = memberStakes[msg.sender].add(msg.value);\n        totalStake = totalStake.add(msg.value);\n        \n        // Calculate and add credibility points\n        uint256 credibilityAdded = msg.value.mul(CREDIBILITY_RATE).div(100);\n        credibilityPoints[recipient] = credibilityPoints[recipient].add(credibilityAdded);\n        \n        emit Deposit(msg.sender, recipient, msg.value, credibilityAdded);\n    }\n    \n\n// Add a new function to check credibility points\nfunction getCredibilityPoints(address member) public view returns (uint256) {\n    return credibilityPoints[member];\n}\n\n    // Function for a user to withdraw their stake\n    function withdraw(address payable account) public onlyRole(MEMBER) {\n        require(currentState != daoState.STAKING, \"The DAO is not in the correct state to withdraw.\");\n        if (currentState == daoState.REVOKING) {\n            bool result = execute_revoke();\n            require(result, \"Schedule revoke delay is not finished yet.\");\n        }\n        if (currentState == daoState.REVOKED || currentState == daoState.COLLECTING) {\n            //Sanity checks\n            if(staking.isDelegator(address(this))){\n                 revert(\"The DAO is in an inconsistent state.\");\n            }\n            require(totalStake!=0, \"Cannot divide by zero.\");\n            //Calculate the withdrawal amount including staking rewards\n            uint amount = address(this)\n                .balance\n                .mul(memberStakes[msg.sender])\n                .div(totalStake);\n            require(check_free_balance() >= amount, \"Not enough free balance for withdrawal.\");\n            Address.sendValue(account, amount);\n            totalStake = totalStake.sub(memberStakes[msg.sender]);\n            memberStakes[msg.sender] = 0;\n            emit withdrawal(msg.sender, account, amount);\n        }\n    }\n\n    // Schedule revoke, admin only\n    function schedule_revoke() public onlyRole(DEFAULT_ADMIN_ROLE){\n        require(currentState == daoState.STAKING, \"The DAO is not in the correct state to schedule a revoke.\");\n        staking.scheduleRevokeDelegation(target);\n        currentState = daoState.REVOKING;\n    }\n    \n    // Try to execute the revoke, returns true if it succeeds, false if it doesn't\n    function execute_revoke() internal onlyRole(MEMBER) returns(bool) {\n        require(currentState == daoState.REVOKING, \"The DAO is not in the correct state to execute a revoke.\");\n        staking.executeDelegationRequest(address(this), target);\n        if (staking.isDelegator(address(this))){\n            return false;\n        } else {\n            currentState = daoState.REVOKED;\n            return true;\n        }\n    }\n\n    // Check how much free balance the DAO currently has. It should be the staking rewards if the DAO state is anything other than REVOKED or COLLECTING. \n    function check_free_balance() public view onlyRole(MEMBER) returns(uint256) {\n        return address(this).balance;\n    }\n    \n    // Change the collator target, admin only\n    function change_target(address newCollator) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(currentState == daoState.REVOKED || currentState == daoState.COLLECTING, \"The DAO is not in the correct state to change staking target.\");\n        target = newCollator;\n    }\n\n    // Reset the DAO state back to COLLECTING, admin only\n    function reset_dao() public onlyRole(DEFAULT_ADMIN_ROLE) {\n        currentState = daoState.COLLECTING;\n    }\n\n\n}"
    },
    "contracts/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.20;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}"
    },
    "contracts/StakingInterface.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.3;\n\n/// @dev The ParachainStaking contract's address.\naddress constant PARACHAIN_STAKING_ADDRESS = 0x0000000000000000000000000000000000000800;\n\n/// @dev The ParachainStaking contract's instance.\nParachainStaking constant PARACHAIN_STAKING_CONTRACT = ParachainStaking(\n    PARACHAIN_STAKING_ADDRESS\n);\n\n/// @author The Moonbeam Team\n/// @title Pallet Parachain Staking Interface\n/// @dev The interface through which solidity contracts will interact with Parachain Staking\n/// We follow this same interface including four-byte function selectors, in the precompile that\n/// wraps the pallet\n/// @custom:address 0x0000000000000000000000000000000000000800\ninterface ParachainStaking {\n    /// @dev Check whether the specified address is currently a staking delegator\n    /// @custom:selector fd8ab482\n    /// @param delegator the address that we want to confirm is a delegator\n    /// @return A boolean confirming whether the address is a delegator\n    function isDelegator(address delegator) external view returns (bool);\n\n    /// @dev Check whether the specified address is currently a collator candidate\n    /// @custom:selector d51b9e93\n    /// @param candidate the address that we want to confirm is a collator andidate\n    /// @return A boolean confirming whether the address is a collator candidate\n    function isCandidate(address candidate) external view returns (bool);\n\n    /// @dev Check whether the specifies address is currently a part of the active set\n    /// @custom:selector 740d7d2a\n    /// @param candidate the address that we want to confirm is a part of the active set\n    /// @return A boolean confirming whether the address is a part of the active set\n    function isSelectedCandidate(\n        address candidate\n    ) external view returns (bool);\n\n    /// @dev Total points awarded to all collators in a particular round\n    /// @custom:selector 9799b4e7\n    /// @param round the round for which we are querying the points total\n    /// @return The total points awarded to all collators in the round\n    function points(uint256 round) external view returns (uint256);\n\n    /// @dev Total points awarded to a specific collator in a particular round.\n    /// A value of `0` may signify that no blocks were produced or that the storage for that round has been removed\n    /// @custom:selector bfea66ac\n    /// @param round the round for which we are querying the awarded points\n    /// @param candidate The candidate to whom the points are awarded\n    /// @return The total points awarded to the collator for the provided round\n    function awardedPoints(\n        uint32 round,\n        address candidate\n    ) external view returns (uint32);\n\n    /// @dev The amount delegated in support of the candidate by the delegator\n    /// @custom:selector a73e51bc\n    /// @param delegator Who made this delegation\n    /// @param candidate The candidate for which the delegation is in support of\n    /// @return The amount of the delegation in support of the candidate by the delegator\n    function delegationAmount(\n        address delegator,\n        address candidate\n    ) external view returns (uint256);\n\n    /// @dev Whether the delegation is in the top delegations\n    /// @custom:selector 91cc8657\n    /// @param delegator Who made this delegation\n    /// @param candidate The candidate for which the delegation is in support of\n    /// @return If delegation is in top delegations (is counted)\n    function isInTopDelegations(\n        address delegator,\n        address candidate\n    ) external view returns (bool);\n\n    /// @dev Get the minimum delegation amount\n    /// @custom:selector 02985992\n    /// @return The minimum delegation amount\n    function minDelegation() external view returns (uint256);\n\n    /// @dev Get the CandidateCount weight hint\n    /// @custom:selector a9a981a3\n    /// @return The CandidateCount weight hint\n    function candidateCount() external view returns (uint256);\n\n    /// @dev Get the current round number\n    /// @custom:selector 146ca531\n    /// @return The current round number\n    function round() external view returns (uint256);\n\n    /// @dev Get the CandidateDelegationCount weight hint\n    /// @custom:selector 2ec087eb\n    /// @param candidate The address for which we are querying the nomination count\n    /// @return The number of nominations backing the collator\n    function candidateDelegationCount(\n        address candidate\n    ) external view returns (uint32);\n\n    /// @dev Get the CandidateAutoCompoundingDelegationCount weight hint\n    /// @custom:selector 905f0806\n    /// @param candidate The address for which we are querying the auto compounding\n    ///     delegation count\n    /// @return The number of auto compounding delegations\n    function candidateAutoCompoundingDelegationCount(\n        address candidate\n    ) external view returns (uint32);\n\n    /// @dev Get the DelegatorDelegationCount weight hint\n    /// @custom:selector 067ec822\n    /// @param delegator The address for which we are querying the delegation count\n    /// @return The number of delegations made by the delegator\n    function delegatorDelegationCount(\n        address delegator\n    ) external view returns (uint256);\n\n    /// @dev Get the selected candidates for the current round\n    /// @custom:selector bcf868a6\n    /// @return The selected candidate accounts\n    function selectedCandidates() external view returns (address[] memory);\n\n    /// @dev Whether there exists a pending request for a delegation made by a delegator\n    /// @custom:selector 3b16def8\n    /// @param delegator the delegator that made the delegation\n    /// @param candidate the candidate for which the delegation was made\n    /// @return Whether a pending request exists for such delegation\n    function delegationRequestIsPending(\n        address delegator,\n        address candidate\n    ) external view returns (bool);\n\n    /// @dev Whether there exists a pending exit for candidate\n    /// @custom:selector 43443682\n    /// @param candidate the candidate for which the exit request was made\n    /// @return Whether a pending request exists for such delegation\n    function candidateExitIsPending(\n        address candidate\n    ) external view returns (bool);\n\n    /// @dev Whether there exists a pending bond less request made by a candidate\n    /// @custom:selector d0deec11\n    /// @param candidate the candidate which made the request\n    /// @return Whether a pending bond less request was made by the candidate\n    function candidateRequestIsPending(\n        address candidate\n    ) external view returns (bool);\n\n    /// @dev Returns the percent value of auto-compound set for a delegation\n    /// @custom:selector b4d4c7fd\n    /// @param delegator the delegator that made the delegation\n    /// @param candidate the candidate for which the delegation was made\n    /// @return Percent of rewarded amount that is auto-compounded on each payout\n    function delegationAutoCompound(\n        address delegator,\n        address candidate\n    ) external view returns (uint8);\n\n    /// @dev Join the set of collator candidates\n    /// @custom:selector 1f2f83ad\n    /// @param amount The amount self-bonded by the caller to become a collator candidate\n    /// @param candidateCount The number of candidates in the CandidatePool\n    function joinCandidates(uint256 amount, uint256 candidateCount) external;\n\n    /// @dev Request to leave the set of collator candidates\n    /// @custom:selector b1a3c1b7\n    /// @param candidateCount The number of candidates in the CandidatePool\n    function scheduleLeaveCandidates(uint256 candidateCount) external;\n\n    /// @dev Execute due request to leave the set of collator candidates\n    /// @custom:selector 3867f308\n    /// @param candidate The candidate address for which the pending exit request will be executed\n    /// @param candidateDelegationCount The number of delegations for the candidate to be revoked\n    function executeLeaveCandidates(\n        address candidate,\n        uint256 candidateDelegationCount\n    ) external;\n\n    /// @dev Cancel request to leave the set of collator candidates\n    /// @custom:selector 9c76ebb4\n    /// @param candidateCount The number of candidates in the CandidatePool\n    function cancelLeaveCandidates(uint256 candidateCount) external;\n\n    /// @dev Temporarily leave the set of collator candidates without unbonding\n    /// @custom:selector a6485ccd\n    function goOffline() external;\n\n    /// @dev Rejoin the set of collator candidates if previously had called `goOffline`\n    /// @custom:selector 6e5b676b\n    function goOnline() external;\n\n    /// @dev Request to bond more for collator candidates\n    /// @custom:selector a52c8643\n    /// @param more The additional amount self-bonded\n    function candidateBondMore(uint256 more) external;\n\n    /// @dev Request to bond less for collator candidates\n    /// @custom:selector 60744ae0\n    /// @param less The amount to be subtracted from self-bond and unreserved\n    function scheduleCandidateBondLess(uint256 less) external;\n\n    /// @dev Execute pending candidate bond request\n    /// @custom:selector 2e290290\n    /// @param candidate The address for the candidate for which the request will be executed\n    function executeCandidateBondLess(address candidate) external;\n\n    /// @dev Cancel pending candidate bond request\n    /// @custom:selector b5ad5f07\n    function cancelCandidateBondLess() external;\n\n    /// @notice DEPRECATED use delegateWithAutoCompound instead for lower weight and better UX\n    /// @dev Make a delegation in support of a collator candidate\n    /// @custom:selector 829f5ee3\n    /// @param candidate The address of the supported collator candidate\n    /// @param amount The amount bonded in support of the collator candidate\n    /// @param candidateDelegationCount The number of delegations in support of the candidate\n    /// @param delegatorDelegationCount The number of existing delegations by the caller\n    function delegate(\n        address candidate,\n        uint256 amount,\n        uint256 candidateDelegationCount,\n        uint256 delegatorDelegationCount\n    ) external;\n\n    /// @dev Make a delegation in support of a collator candidate\n    /// @custom:selector 4b8bc9bf\n    /// @param candidate The address of the supported collator candidate\n    /// @param amount The amount bonded in support of the collator candidate\n    /// @param autoCompound The percent of reward that should be auto-compounded\n    /// @param candidateDelegationCount The number of delegations in support of the candidate\n    /// @param candidateAutoCompoundingDelegationCount The number of auto-compounding delegations\n    /// in support of the candidate\n    /// @param delegatorDelegationCount The number of existing delegations by the caller\n    function delegateWithAutoCompound(\n        address candidate,\n        uint256 amount,\n        uint8 autoCompound,\n        uint256 candidateDelegationCount,\n        uint256 candidateAutoCompoundingDelegationCount,\n        uint256 delegatorDelegationCount\n    ) external;\n\n    /// @dev Request to revoke an existing delegation\n    /// @custom:selector 1a1c740c\n    /// @param candidate The address of the collator candidate which will no longer be supported\n    function scheduleRevokeDelegation(address candidate) external;\n\n    /// @dev Bond more for delegators with respect to a specific collator candidate\n    /// @custom:selector 0465135b\n    /// @param candidate The address of the collator candidate for which delegation shall increase\n    /// @param more The amount by which the delegation is increased\n    function delegatorBondMore(address candidate, uint256 more) external;\n\n    /// @dev Request to bond less for delegators with respect to a specific collator candidate\n    /// @custom:selector c172fd2b\n    /// @param candidate The address of the collator candidate for which delegation shall decrease\n    /// @param less The amount by which the delegation is decreased (upon execution)\n    function scheduleDelegatorBondLess(\n        address candidate,\n        uint256 less\n    ) external;\n\n    /// @dev Execute pending delegation request (if exists && is due)\n    /// @custom:selector e98c8abe\n    /// @param delegator The address of the delegator\n    /// @param candidate The address of the candidate\n    function executeDelegationRequest(\n        address delegator,\n        address candidate\n    ) external;\n\n    /// @dev Cancel pending delegation request (already made in support of input by caller)\n    /// @custom:selector c90eee83\n    /// @param candidate The address of the candidate\n    function cancelDelegationRequest(address candidate) external;\n\n    /// @dev Sets an auto-compound value for a delegation\n    /// @custom:selector faa1786f\n    /// @param candidate The address of the supported collator candidate\n    /// @param value The percent of reward that should be auto-compounded\n    /// @param candidateAutoCompoundingDelegationCount The number of auto-compounding delegations\n    /// in support of the candidate\n    /// @param delegatorDelegationCount The number of existing delegations by the caller\n    function setAutoCompound(\n        address candidate,\n        uint8 value,\n        uint256 candidateAutoCompoundingDelegationCount,\n        uint256 delegatorDelegationCount\n    ) external;\n\n    /// @dev Fetch the total staked amount of a delegator, regardless of the\n    /// candidate.\n    /// @custom:selector e6861713\n    /// @param delegator Address of the delegator.\n    /// @return Total amount of stake.\n    function getDelegatorTotalStaked(\n        address delegator\n    ) external view returns (uint256);\n\n    /// @dev Fetch the total staked towards a candidate.\n    /// @custom:selector bc5a1043\n    /// @param candidate Address of the candidate.\n    /// @return Total amount of stake.\n    function getCandidateTotalCounted(\n        address candidate\n    ) external view returns (uint256);\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}