{"version":3,"sources":["../src/index.ts","../src/subscription-manager/chainHeadFollow.ts","../src/subscription-manager/transaction-submit-watch.ts","../src/subscription-manager/subscription-manager.ts","../src/get-sync-provider.ts"],"sourcesContent":["export * from \"./get-sync-provider\"\n","import { SubscriptionId, SubscriptionLogic } from \"@/internal-types\"\n\nconst START_METHOD = \"chainHead_unstable_follow\"\nconst STOP_METHOD = \"chainHead_unstable_unfollow\"\nconst NOTIFICATION_METHOD = \"chainHead_unstable_followEvent\"\nconst ABORT_EVENT = \"stop\"\n\nconst terminalEvents = new Set([\n  ABORT_EVENT,\n  \"operationInaccessible\",\n  \"operationError\",\n])\n\nexport const chainHeadFollow = (\n  onMessage: (msg: string) => void,\n): SubscriptionLogic => ({\n  onSent(parsed) {\n    if (parsed.method === START_METHOD)\n      return {\n        type: \"subscribe\",\n        id: parsed.id,\n        onRes: (innerParsed) =>\n          innerParsed.id === parsed.id ? { id: innerParsed.result } : null,\n      }\n\n    if (parsed.method === STOP_METHOD)\n      return {\n        type: \"unsubscribe\",\n        id: Object.values(parsed.params)[0] as string,\n      }\n\n    return null\n  },\n  onNotification(parsed) {\n    if (parsed.method !== NOTIFICATION_METHOD) return null\n\n    return terminalEvents.has(parsed.params.result.event)\n      ? {\n          type: \"end\",\n          id: parsed.params.subscription as SubscriptionId,\n        }\n      : null\n  },\n  onAbort: (id) => {\n    onMessage(\n      JSON.stringify({\n        jsonrpc: \"2.0\",\n        method: NOTIFICATION_METHOD,\n        params: {\n          subscription: id,\n          result: {\n            event: ABORT_EVENT,\n          },\n        },\n      }),\n    )\n  },\n})\n","import { SubscriptionId, SubscriptionLogic } from \"@/internal-types\"\n\nconst START_METHOD = \"transaction_unstable_submitAndWatch\"\nconst STOP_METHOD = \"transaction_unstable_unwatch\"\nconst NOTIFICATION_METHOD = \"transaction_unstable_watchEvent\"\nconst ABORT_EVENT = \"dropped\"\n\nconst terminalEvents = new Set([ABORT_EVENT, \"finalized\", \"error\", \"invalid\"])\n\nexport const txSubmitAndWatch = (\n  onMessage: (msg: string) => void,\n): SubscriptionLogic => ({\n  onSent(parsed) {\n    if (parsed.method === START_METHOD)\n      return {\n        type: \"subscribe\",\n        id: parsed.id,\n        onRes: (innerParsed) =>\n          innerParsed.id === parsed.id ? { id: innerParsed.result } : null,\n      }\n\n    if (parsed.method === STOP_METHOD)\n      return {\n        type: \"unsubscribe\",\n        id: Object.values(parsed.params)[0] as string,\n      }\n\n    return null\n  },\n  onNotification(parsed) {\n    if (parsed.method !== NOTIFICATION_METHOD) return null\n\n    return terminalEvents.has(parsed.params.result.event)\n      ? {\n          type: \"end\",\n          id: parsed.params.subscription as SubscriptionId,\n        }\n      : null\n  },\n  onAbort: (id) => {\n    onMessage(\n      JSON.stringify({\n        jsonrpc: \"2.0\",\n        method: NOTIFICATION_METHOD,\n        params: {\n          subscription: id,\n          result: {\n            event: ABORT_EVENT,\n          },\n        },\n      }),\n    )\n  },\n})\n","import type {\n  RequestId,\n  SubscriptionId,\n  SubscriptionLogic,\n} from \"../internal-types\"\nimport { chainHeadFollow } from \"./chainHeadFollow\"\nimport { txSubmitAndWatch } from \"./transaction-submit-watch\"\n\nexport const addSubscription = ({\n  onSent,\n  onNotification,\n  onAbort,\n}: SubscriptionLogic) => {\n  const preActive = new Map<\n    RequestId,\n    (parsed: any) => { id: SubscriptionId } | null\n  >()\n  const active = new Set<SubscriptionId>()\n\n  const onDisconnect = () => {\n    preActive.clear()\n    active.clear()\n  }\n\n  return {\n    onSent(parsed: any) {\n      const result = onSent(parsed)\n      if (!result) return\n      if (result.type === \"subscribe\") {\n        preActive.set(result.id, result.onRes)\n      } else {\n        active.delete(result.id)\n      }\n    },\n    onResponse(parsed: any) {\n      const match = preActive.get(parsed.id)?.(parsed)\n      if (!match) return\n      preActive.delete(parsed.id)\n      active.add(match.id)\n    },\n    onNotifiaction(parsed: any) {\n      const result = onNotification(parsed)\n      if (!result) return\n      active.delete(result.id)\n    },\n    onDisconnect,\n    onAbort() {\n      const activeCopy = [...active]\n      onDisconnect()\n      activeCopy.forEach(onAbort)\n    },\n  }\n}\n\nexport const getSubscriptionManager = (onMessage: (msg: string) => void) => {\n  const subscriptions = [chainHeadFollow, txSubmitAndWatch].map((logic) =>\n    addSubscription(logic(onMessage)),\n  )\n\n  return {\n    onSent(parsed: any) {\n      subscriptions.forEach((s) => {\n        s.onSent(parsed)\n      })\n    },\n    onResponse(parsed: any) {\n      subscriptions.forEach((s) => {\n        s.onResponse(parsed)\n      })\n    },\n    onNotifiaction(parsed: any) {\n      subscriptions.forEach((s) => {\n        s.onNotifiaction(parsed)\n      })\n    },\n    onDisconnect() {\n      subscriptions.forEach((s) => s.onDisconnect())\n    },\n    onAbort() {\n      subscriptions.forEach((s) => s.onAbort())\n    },\n  }\n}\n","import type { RequestId } from \"./internal-types\"\nimport type {\n  JsonRpcProvider,\n  JsonRpcConnection,\n} from \"@polkadot-api/json-rpc-provider\"\nimport { getSubscriptionManager } from \"./subscription-manager\"\n\nexport type AsyncJsonRpcProvider = (\n  onMessage: (message: string) => void,\n  onHalt: () => void,\n) => JsonRpcConnection\n\nexport const getSyncProvider =\n  (input: () => Promise<AsyncJsonRpcProvider>): JsonRpcProvider =>\n  (onMessage) => {\n    // if it's null it means that the consumer has called `disconnect`\n    // of it's a Promise it means that it's being respolved, otherwise it's resolved\n    let provider: JsonRpcConnection | Promise<JsonRpcConnection> | null\n\n    let bufferedMessages: Array<string> = []\n    const pendingResponses = new Set<RequestId>()\n    const subscriptionManager = getSubscriptionManager(onMessage)\n\n    const onMessageProxy = (message: string) => {\n      let parsed: any\n      try {\n        parsed = JSON.parse(message)\n      } catch (_) {\n        console.error(`Unable to parse incoming message: ${message}`)\n        return\n      }\n\n      if (parsed.id !== undefined) {\n        pendingResponses.delete(parsed.id)\n        subscriptionManager.onResponse(parsed)\n      } else {\n        subscriptionManager.onNotifiaction(parsed)\n      }\n\n      onMessage(message)\n    }\n\n    const send = (message: string) => {\n      if (!provider) return\n\n      const parsed = JSON.parse(message)\n      subscriptionManager.onSent(parsed)\n      if (parsed.id) pendingResponses.add(parsed.id)\n\n      if (provider instanceof Promise) {\n        bufferedMessages.push(message)\n      } else provider.send(message)\n    }\n\n    const onHalt = (): Promise<JsonRpcConnection> => {\n      bufferedMessages = []\n      const pendingResponsesCopy = [...pendingResponses]\n      pendingResponses.clear()\n\n      // it means that the user has disconnected while the\n      // provider promise was being rejected. Therefore, we must\n      // throw to prevent the Promise from recovering.\n      // The rejection will be handled from the teardown logic.\n      if (!provider) throw null\n\n      // It needs to restart before sending the errored\n      // responses/notifications because the consumer may\n      // react to those by sending new requests\n      const result = start()\n\n      subscriptionManager.onAbort()\n      pendingResponsesCopy.forEach((id) => {\n        onMessage(\n          JSON.stringify({\n            jsonrpc: \"2.0\",\n            error: { code: -32603, message: \"Internal error\" },\n            id,\n          }),\n        )\n      })\n\n      return result\n    }\n\n    const start = (): Promise<JsonRpcConnection> => {\n      const onResolve = (getProvider: AsyncJsonRpcProvider) => {\n        let halted = false\n        const _onHalt = () => {\n          if (halted) return\n          halted = true\n          onHalt()\n        }\n        const _onMessageProxy = (msg: string) => {\n          if (halted) return\n          onMessageProxy(msg)\n        }\n\n        const result = getProvider(_onMessageProxy, _onHalt)\n        bufferedMessages.forEach((m) => {\n          result.send(m)\n        })\n        bufferedMessages = []\n        return (provider = result)\n      }\n\n      provider = input().then(onResolve, withMacroTask(onHalt))\n      return provider\n    }\n\n    const disconnect = () => {\n      if (!provider) return\n\n      const finishIt = (input: JsonRpcConnection | null) => {\n        subscriptionManager.onDisconnect()\n        pendingResponses.clear()\n        provider = null\n        input?.disconnect()\n      }\n\n      if (provider instanceof Promise) {\n        provider.then(finishIt, finishIt)\n        provider = null\n      } else finishIt(provider)\n    }\n\n    start()\n    return {\n      send,\n      disconnect,\n    }\n  }\n\nconst withMacroTask =\n  <Args extends Array<any>, T>(\n    inputFn: (...args: Args) => Promise<T>,\n  ): ((...args: Args) => Promise<T>) =>\n  (...args) =>\n    new Promise((res) => setTimeout(res, 0)).then(() => inputFn(...args))\n"],"mappings":"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","names":["START_METHOD","STOP_METHOD","NOTIFICATION_METHOD","ABORT_EVENT","terminalEvents","input"]}