{"version":3,"sources":["../../src/index.ts","../../src/subscription-manager/chainHeadFollow.ts","../../src/subscription-manager/transaction-submit-watch.ts","../../src/subscription-manager/subscription-manager.ts","../../src/get-sync-provider.ts"],"sourcesContent":["export * from \"./get-sync-provider\"\n","import { SubscriptionId, SubscriptionLogic } from \"@/internal-types\"\n\nconst START_METHOD = \"chainHead_unstable_follow\"\nconst STOP_METHOD = \"chainHead_unstable_unfollow\"\nconst NOTIFICATION_METHOD = \"chainHead_unstable_followEvent\"\nconst ABORT_EVENT = \"stop\"\n\nconst terminalEvents = new Set([\n  ABORT_EVENT,\n  \"operationInaccessible\",\n  \"operationError\",\n])\n\nexport const chainHeadFollow = (\n  onMessage: (msg: string) => void,\n): SubscriptionLogic => ({\n  onSent(parsed) {\n    if (parsed.method === START_METHOD)\n      return {\n        type: \"subscribe\",\n        id: parsed.id,\n        onRes: (innerParsed) =>\n          innerParsed.id === parsed.id ? { id: innerParsed.result } : null,\n      }\n\n    if (parsed.method === STOP_METHOD)\n      return {\n        type: \"unsubscribe\",\n        id: Object.values(parsed.params)[0] as string,\n      }\n\n    return null\n  },\n  onNotification(parsed) {\n    if (parsed.method !== NOTIFICATION_METHOD) return null\n\n    return terminalEvents.has(parsed.params.result.event)\n      ? {\n          type: \"end\",\n          id: parsed.params.subscription as SubscriptionId,\n        }\n      : null\n  },\n  onAbort: (id) => {\n    onMessage(\n      JSON.stringify({\n        jsonrpc: \"2.0\",\n        method: NOTIFICATION_METHOD,\n        params: {\n          subscription: id,\n          result: {\n            event: ABORT_EVENT,\n          },\n        },\n      }),\n    )\n  },\n})\n","import { SubscriptionId, SubscriptionLogic } from \"@/internal-types\"\n\nconst START_METHOD = \"transaction_unstable_submitAndWatch\"\nconst STOP_METHOD = \"transaction_unstable_unwatch\"\nconst NOTIFICATION_METHOD = \"transaction_unstable_watchEvent\"\nconst ABORT_EVENT = \"dropped\"\n\nconst terminalEvents = new Set([ABORT_EVENT, \"finalized\", \"error\", \"invalid\"])\n\nexport const txSubmitAndWatch = (\n  onMessage: (msg: string) => void,\n): SubscriptionLogic => ({\n  onSent(parsed) {\n    if (parsed.method === START_METHOD)\n      return {\n        type: \"subscribe\",\n        id: parsed.id,\n        onRes: (innerParsed) =>\n          innerParsed.id === parsed.id ? { id: innerParsed.result } : null,\n      }\n\n    if (parsed.method === STOP_METHOD)\n      return {\n        type: \"unsubscribe\",\n        id: Object.values(parsed.params)[0] as string,\n      }\n\n    return null\n  },\n  onNotification(parsed) {\n    if (parsed.method !== NOTIFICATION_METHOD) return null\n\n    return terminalEvents.has(parsed.params.result.event)\n      ? {\n          type: \"end\",\n          id: parsed.params.subscription as SubscriptionId,\n        }\n      : null\n  },\n  onAbort: (id) => {\n    onMessage(\n      JSON.stringify({\n        jsonrpc: \"2.0\",\n        method: NOTIFICATION_METHOD,\n        params: {\n          subscription: id,\n          result: {\n            event: ABORT_EVENT,\n          },\n        },\n      }),\n    )\n  },\n})\n","import type {\n  RequestId,\n  SubscriptionId,\n  SubscriptionLogic,\n} from \"../internal-types\"\nimport { chainHeadFollow } from \"./chainHeadFollow\"\nimport { txSubmitAndWatch } from \"./transaction-submit-watch\"\n\nexport const addSubscription = ({\n  onSent,\n  onNotification,\n  onAbort,\n}: SubscriptionLogic) => {\n  const preActive = new Map<\n    RequestId,\n    (parsed: any) => { id: SubscriptionId } | null\n  >()\n  const active = new Set<SubscriptionId>()\n\n  const onDisconnect = () => {\n    preActive.clear()\n    active.clear()\n  }\n\n  return {\n    onSent(parsed: any) {\n      const result = onSent(parsed)\n      if (!result) return\n      if (result.type === \"subscribe\") {\n        preActive.set(result.id, result.onRes)\n      } else {\n        active.delete(result.id)\n      }\n    },\n    onResponse(parsed: any) {\n      const match = preActive.get(parsed.id)?.(parsed)\n      if (!match) return\n      preActive.delete(parsed.id)\n      active.add(match.id)\n    },\n    onNotifiaction(parsed: any) {\n      const result = onNotification(parsed)\n      if (!result) return\n      active.delete(result.id)\n    },\n    onDisconnect,\n    onAbort() {\n      const activeCopy = [...active]\n      onDisconnect()\n      activeCopy.forEach(onAbort)\n    },\n  }\n}\n\nexport const getSubscriptionManager = (onMessage: (msg: string) => void) => {\n  const subscriptions = [chainHeadFollow, txSubmitAndWatch].map((logic) =>\n    addSubscription(logic(onMessage)),\n  )\n\n  return {\n    onSent(parsed: any) {\n      subscriptions.forEach((s) => {\n        s.onSent(parsed)\n      })\n    },\n    onResponse(parsed: any) {\n      subscriptions.forEach((s) => {\n        s.onResponse(parsed)\n      })\n    },\n    onNotifiaction(parsed: any) {\n      subscriptions.forEach((s) => {\n        s.onNotifiaction(parsed)\n      })\n    },\n    onDisconnect() {\n      subscriptions.forEach((s) => s.onDisconnect())\n    },\n    onAbort() {\n      subscriptions.forEach((s) => s.onAbort())\n    },\n  }\n}\n","import type { RequestId } from \"./internal-types\"\nimport type {\n  JsonRpcProvider,\n  JsonRpcConnection,\n} from \"@polkadot-api/json-rpc-provider\"\nimport { getSubscriptionManager } from \"./subscription-manager\"\n\nexport type AsyncJsonRpcProvider = (\n  onMessage: (message: string) => void,\n  onHalt: () => void,\n) => JsonRpcConnection\n\nexport const getSyncProvider =\n  (input: () => Promise<AsyncJsonRpcProvider>): JsonRpcProvider =>\n  (onMessage) => {\n    // if it's null it means that the consumer has called `disconnect`\n    // of it's a Promise it means that it's being respolved, otherwise it's resolved\n    let provider: JsonRpcConnection | Promise<JsonRpcConnection> | null\n\n    let bufferedMessages: Array<string> = []\n    const pendingResponses = new Set<RequestId>()\n    const subscriptionManager = getSubscriptionManager(onMessage)\n\n    const onMessageProxy = (message: string) => {\n      let parsed: any\n      try {\n        parsed = JSON.parse(message)\n      } catch (_) {\n        console.error(`Unable to parse incoming message: ${message}`)\n        return\n      }\n\n      if (parsed.id !== undefined) {\n        pendingResponses.delete(parsed.id)\n        subscriptionManager.onResponse(parsed)\n      } else {\n        subscriptionManager.onNotifiaction(parsed)\n      }\n\n      onMessage(message)\n    }\n\n    const send = (message: string) => {\n      if (!provider) return\n\n      const parsed = JSON.parse(message)\n      subscriptionManager.onSent(parsed)\n      if (parsed.id) pendingResponses.add(parsed.id)\n\n      if (provider instanceof Promise) {\n        bufferedMessages.push(message)\n      } else provider.send(message)\n    }\n\n    const onHalt = (): Promise<JsonRpcConnection> => {\n      bufferedMessages = []\n      const pendingResponsesCopy = [...pendingResponses]\n      pendingResponses.clear()\n\n      // it means that the user has disconnected while the\n      // provider promise was being rejected. Therefore, we must\n      // throw to prevent the Promise from recovering.\n      // The rejection will be handled from the teardown logic.\n      if (!provider) throw null\n\n      // It needs to restart before sending the errored\n      // responses/notifications because the consumer may\n      // react to those by sending new requests\n      const result = start()\n\n      subscriptionManager.onAbort()\n      pendingResponsesCopy.forEach((id) => {\n        onMessage(\n          JSON.stringify({\n            jsonrpc: \"2.0\",\n            error: { code: -32603, message: \"Internal error\" },\n            id,\n          }),\n        )\n      })\n\n      return result\n    }\n\n    const start = (): Promise<JsonRpcConnection> => {\n      const onResolve = (getProvider: AsyncJsonRpcProvider) => {\n        let halted = false\n        const _onHalt = () => {\n          if (halted) return\n          halted = true\n          onHalt()\n        }\n        const _onMessageProxy = (msg: string) => {\n          if (halted) return\n          onMessageProxy(msg)\n        }\n\n        const result = getProvider(_onMessageProxy, _onHalt)\n        bufferedMessages.forEach((m) => {\n          result.send(m)\n        })\n        bufferedMessages = []\n        return (provider = result)\n      }\n\n      provider = input().then(onResolve, withMacroTask(onHalt))\n      return provider\n    }\n\n    const disconnect = () => {\n      if (!provider) return\n\n      const finishIt = (input: JsonRpcConnection | null) => {\n        subscriptionManager.onDisconnect()\n        pendingResponses.clear()\n        provider = null\n        input?.disconnect()\n      }\n\n      if (provider instanceof Promise) {\n        provider.then(finishIt, finishIt)\n        provider = null\n      } else finishIt(provider)\n    }\n\n    start()\n    return {\n      send,\n      disconnect,\n    }\n  }\n\nconst withMacroTask =\n  <Args extends Array<any>, T>(\n    inputFn: (...args: Args) => Promise<T>,\n  ): ((...args: Args) => Promise<T>) =>\n  (...args) =>\n    new Promise((res) => setTimeout(res, 0)).then(() => inputFn(...args))\n"],"mappings":"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","names":["src_exports","__export","getSyncProvider","__toCommonJS","START_METHOD","STOP_METHOD","NOTIFICATION_METHOD","ABORT_EVENT","terminalEvents","chainHeadFollow","onMessage","parsed","innerParsed","id","START_METHOD","STOP_METHOD","NOTIFICATION_METHOD","ABORT_EVENT","terminalEvents","txSubmitAndWatch","onMessage","parsed","innerParsed","id","addSubscription","onSent","onNotification","onAbort","preActive","active","onDisconnect","parsed","result","match","activeCopy","getSubscriptionManager","onMessage","subscriptions","chainHeadFollow","txSubmitAndWatch","logic","s","getSyncProvider","input","onMessage","provider","bufferedMessages","pendingResponses","subscriptionManager","getSubscriptionManager","onMessageProxy","message","parsed","send","onHalt","pendingResponsesCopy","result","start","id","onResolve","getProvider","halted","msg","m","withMacroTask","disconnect","finishIt","inputFn","args","res"]}