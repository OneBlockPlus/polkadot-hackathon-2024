import * as scale_ts from 'scale-ts';
import { Codec, Encoder, Decoder, StringRecord, CodecType, EncoderType, DecoderType } from 'scale-ts';
export { Bytes, Codec, CodecType, Decoder, DecoderType, Encoder, EncoderType, Option, Result, ResultPayload, StringRecord, Struct, Tuple, Vector, _void, bool, compact, createCodec, createDecoder, enhanceCodec, enhanceDecoder, enhanceEncoder, i128, i16, i256, i32, i64, i8, str, u128, u16, u256, u32, u64, u8 } from 'scale-ts';

type SS58String = string & {
    __SS58String?: unknown;
};
type SS58AddressInfo = {
    isValid: false;
} | {
    isValid: true;
    ss58Format: number;
    publicKey: Uint8Array;
};
declare const getSs58AddressInfo: (address: SS58String) => SS58AddressInfo;
declare const fromBufferToBase58: (ss58Format: number) => (publicKey: Uint8Array) => SS58String;

declare const AccountId: (ss58Format?: number, nBytes?: 32 | 33) => scale_ts.Codec<SS58String>;

type HexString = string & {
    __hexString?: unknown;
};
declare const Hex: {
    (nBytes?: number): Codec<HexString>;
    enc: (nBytes?: number) => Encoder<HexString>;
    dec: (nBytes?: number) => Decoder<HexString>;
};

declare class Binary {
    #private;
    constructor(data: Uint8Array);
    asText: () => string;
    asHex: () => string;
    asBytes: () => Uint8Array;
    static fromText(input: string): Binary;
    static fromHex(input: HexString): Binary;
    static fromBytes(input: Uint8Array): Binary;
}
declare class FixedSizeBinary<_L extends number> extends Binary {
    constructor(data: Uint8Array);
    static fromArray<L extends number, I extends Array<number> & {
        length: L;
    }>(input: I): FixedSizeBinary<L>;
}
declare const Bin: {
    (nBytes?: number): Codec<Binary>;
    enc: (nBytes?: number) => Encoder<Binary>;
    dec: (nBytes?: number) => Decoder<Binary>;
};

interface BitSequence {
    bitsLen: number;
    bytes: Uint8Array;
}
declare const bitSequence: scale_ts.Codec<BitSequence>;

declare const char: scale_ts.Codec<string>;

declare const compactNumber: Codec<number>;
declare const compactBn: Codec<bigint>;

declare const fixedStr: (nBytes: number) => scale_ts.Codec<string>;

declare const selfEncoder: <T>(value: () => Encoder<T>) => Encoder<T>;
declare const selfDecoder: <T>(value: () => Decoder<T>) => Decoder<T>;
declare const Self: <T>(value: () => Codec<T>) => Codec<T>;

type Tuple<T, N extends number> = readonly [T, ...T[]] & {
    length: N;
};
type Push<T extends any[], V> = [...T, V];
type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;
type LastOf<T> = UnionToIntersection<T extends any ? () => T : never> extends () => infer R ? R : never;
type TuplifyUnion<T, L = LastOf<T>, N = [T] extends [never] ? true : false> = true extends N ? [] : Push<TuplifyUnion<Exclude<T, L>>, L>;
type RestrictedLenTuple<T, O extends StringRecord<any>> = Tuple<T, TuplifyUnion<keyof O> extends Tuple<any, infer V> ? V : 0>;
type ExtractEnumValue<T extends {
    type: string;
    value?: any;
}, K extends string> = T extends {
    type: K;
    value: infer R;
} ? R : never;
interface Discriminant<T extends {
    type: string;
    value?: any;
}> {
    is<K extends T["type"]>(this: Enum<T>, type: K): this is Enum<{
        type: K;
        value: ExtractEnumValue<T, K>;
    }>;
    as<K extends T["type"]>(type: K): ExtractEnumValue<T, K>;
}
declare const _Enum: {};
type Enum<T extends {
    type: string;
    value?: any;
}> = T & Discriminant<T>;
declare const Enum: <T extends {
    type: string;
    value?: any;
}, Key extends T["type"]>(type: Key, ...args: ExtractEnumValue<T, Key> extends undefined ? [] : [value: ExtractEnumValue<T, Key>]) => Enum<ExtractEnumValue<T, Key> extends undefined ? T : ExtractEnumValue<T, Key> extends never ? T : {
    type: Key;
    value: ExtractEnumValue<T, Key>;
}>;
declare const Variant: {
    <O extends StringRecord<Codec<any>>>(inner: O, indexes?: RestrictedLenTuple<number, O> | undefined): Codec<Enum<{ [K in keyof O]: K extends string ? {
        type: K;
        value: CodecType<O[K]>;
    } : never; }[keyof O]>>;
    enc: <O_1 extends StringRecord<Encoder<any>>>(inner: O_1, x?: RestrictedLenTuple<number, O_1> | undefined) => Encoder<Enum<{ [K_1 in keyof O_1]: K_1 extends string ? {
        type: K_1;
        value: EncoderType<O_1[K_1]>;
    } : never; }[keyof O_1]>>;
    dec: <O_2 extends StringRecord<Decoder<any>>>(inner: O_2, x?: RestrictedLenTuple<number, O_2> | undefined) => Decoder<Enum<{ [K_2 in keyof O_2]: K_2 extends string ? {
        type: K_2;
        value: DecoderType<O_2[K_2]>;
    } : never; }[keyof O_2]>>;
};

declare const blockHeader: Codec<{
    parentHash: HexString;
    number: number;
    stateRoot: HexString;
    extrinsicRoot: HexString;
    digests: Enum<{
        type: "consensus";
        value: {
            engine: string;
            payload: HexString;
        };
    } | {
        type: "seal";
        value: {
            engine: string;
            payload: HexString;
        };
    } | {
        type: "preRuntime";
        value: {
            engine: string;
            payload: HexString;
        };
    } | {
        type: "runtimeUpdated";
        value: undefined;
    }>[];
}>;
type BlockHeader = CodecType<typeof blockHeader>;

declare const lookup: scale_ts.Codec<{
    id: number;
    path: string[];
    params: {
        name: string;
        type: number | undefined;
    }[];
    def: {
        tag: "composite";
        value: {
            name: string | undefined;
            type: number;
            typeName: string | undefined;
            docs: string[];
        }[];
    } | {
        tag: "variant";
        value: {
            name: string;
            fields: {
                name: string | undefined;
                type: number;
                typeName: string | undefined;
                docs: string[];
            }[];
            index: number;
            docs: string[];
        }[];
    } | {
        tag: "sequence";
        value: number;
    } | {
        tag: "array";
        value: {
            len: number;
            type: number;
        };
    } | {
        tag: "tuple";
        value: number[];
    } | {
        tag: "primitive";
        value: {
            tag: "bool";
            value: undefined;
        } | {
            tag: "char";
            value: undefined;
        } | {
            tag: "str";
            value: undefined;
        } | {
            tag: "u8";
            value: undefined;
        } | {
            tag: "u16";
            value: undefined;
        } | {
            tag: "u32";
            value: undefined;
        } | {
            tag: "u64";
            value: undefined;
        } | {
            tag: "u128";
            value: undefined;
        } | {
            tag: "u256";
            value: undefined;
        } | {
            tag: "i8";
            value: undefined;
        } | {
            tag: "i16";
            value: undefined;
        } | {
            tag: "i32";
            value: undefined;
        } | {
            tag: "i64";
            value: undefined;
        } | {
            tag: "i128";
            value: undefined;
        } | {
            tag: "i256";
            value: undefined;
        };
    } | {
        tag: "compact";
        value: number;
    } | {
        tag: "bitSequence";
        value: {
            bitStoreType: number;
            bitOrderType: number;
        };
    };
    docs: string[];
}[]>;
type V14Lookup = CodecType<typeof lookup>;

declare const extrinsic: scale_ts.Codec<{
    version: number;
    address: number;
    call: number;
    signature: number;
    extra: number;
    signedExtensions: {
        identifier: string;
        type: number;
        additionalSigned: number;
    }[];
}>;
type V15Extrinsic = CodecType<typeof extrinsic>;
declare const v15: scale_ts.Codec<{
    lookup: {
        id: number;
        path: string[];
        params: {
            name: string;
            type: number | undefined;
        }[];
        def: {
            tag: "composite";
            value: {
                name: string | undefined;
                type: number;
                typeName: string | undefined;
                docs: string[];
            }[];
        } | {
            tag: "variant";
            value: {
                name: string;
                fields: {
                    name: string | undefined;
                    type: number;
                    typeName: string | undefined;
                    docs: string[];
                }[];
                index: number;
                docs: string[];
            }[];
        } | {
            tag: "sequence";
            value: number;
        } | {
            tag: "array";
            value: {
                len: number;
                type: number;
            };
        } | {
            tag: "tuple";
            value: number[];
        } | {
            tag: "primitive";
            value: {
                tag: "bool";
                value: undefined;
            } | {
                tag: "char";
                value: undefined;
            } | {
                tag: "str";
                value: undefined;
            } | {
                tag: "u8";
                value: undefined;
            } | {
                tag: "u16";
                value: undefined;
            } | {
                tag: "u32";
                value: undefined;
            } | {
                tag: "u64";
                value: undefined;
            } | {
                tag: "u128";
                value: undefined;
            } | {
                tag: "u256";
                value: undefined;
            } | {
                tag: "i8";
                value: undefined;
            } | {
                tag: "i16";
                value: undefined;
            } | {
                tag: "i32";
                value: undefined;
            } | {
                tag: "i64";
                value: undefined;
            } | {
                tag: "i128";
                value: undefined;
            } | {
                tag: "i256";
                value: undefined;
            };
        } | {
            tag: "compact";
            value: number;
        } | {
            tag: "bitSequence";
            value: {
                bitStoreType: number;
                bitOrderType: number;
            };
        };
        docs: string[];
    }[];
    pallets: {
        name: string;
        storage: {
            prefix: string;
            items: {
                name: string;
                modifier: number;
                type: {
                    tag: "map";
                    value: {
                        hashers: ({
                            tag: "Blake2128";
                            value: undefined;
                        } | {
                            tag: "Blake2256";
                            value: undefined;
                        } | {
                            tag: "Blake2128Concat";
                            value: undefined;
                        } | {
                            tag: "Twox128";
                            value: undefined;
                        } | {
                            tag: "Twox256";
                            value: undefined;
                        } | {
                            tag: "Twox64Concat";
                            value: undefined;
                        } | {
                            tag: "Identity";
                            value: undefined;
                        })[];
                        key: number;
                        value: number;
                    };
                } | {
                    tag: "plain";
                    value: number;
                };
                fallback: HexString;
                docs: string[];
            }[];
        } | undefined;
        calls: number | undefined;
        events: number | undefined;
        constants: {
            name: string;
            type: number;
            value: HexString;
            docs: string[];
        }[];
        errors: number | undefined;
        index: number;
        docs: string[];
    }[];
    extrinsic: {
        version: number;
        address: number;
        call: number;
        signature: number;
        extra: number;
        signedExtensions: {
            identifier: string;
            type: number;
            additionalSigned: number;
        }[];
    };
    type: number;
    apis: {
        name: string;
        methods: {
            name: string;
            inputs: {
                name: string;
                type: number;
            }[];
            output: number;
            docs: string[];
        }[];
        docs: string[];
    }[];
    outerEnums: {
        call: number;
        event: number;
        error: number;
    };
    custom: [string, {
        type: number;
        value: HexString;
    }][];
}>;
type V15 = CodecType<typeof v15>;

declare const metadata: Codec<{
    magicNumber: number;
    metadata: {
        tag: "v0";
        value: unknown;
    } | {
        tag: "v1";
        value: unknown;
    } | {
        tag: "v2";
        value: unknown;
    } | {
        tag: "v3";
        value: unknown;
    } | {
        tag: "v4";
        value: unknown;
    } | {
        tag: "v5";
        value: unknown;
    } | {
        tag: "v6";
        value: unknown;
    } | {
        tag: "v7";
        value: unknown;
    } | {
        tag: "v8";
        value: unknown;
    } | {
        tag: "v9";
        value: unknown;
    } | {
        tag: "v10";
        value: unknown;
    } | {
        tag: "v11";
        value: unknown;
    } | {
        tag: "v12";
        value: unknown;
    } | {
        tag: "v13";
        value: unknown;
    } | {
        tag: "v14";
        value: unknown;
    } | {
        tag: "v15";
        value: {
            lookup: {
                id: number;
                path: string[];
                params: {
                    name: string;
                    type: number | undefined;
                }[];
                def: {
                    tag: "composite";
                    value: {
                        name: string | undefined;
                        type: number;
                        typeName: string | undefined;
                        docs: string[];
                    }[];
                } | {
                    tag: "variant";
                    value: {
                        name: string;
                        fields: {
                            name: string | undefined;
                            type: number;
                            typeName: string | undefined;
                            docs: string[];
                        }[];
                        index: number;
                        docs: string[];
                    }[];
                } | {
                    tag: "sequence";
                    value: number;
                } | {
                    tag: "array";
                    value: {
                        len: number;
                        type: number;
                    };
                } | {
                    tag: "tuple";
                    value: number[];
                } | {
                    tag: "primitive";
                    value: {
                        tag: "bool";
                        value: undefined;
                    } | {
                        tag: "char";
                        value: undefined;
                    } | {
                        tag: "str";
                        value: undefined;
                    } | {
                        tag: "u8";
                        value: undefined;
                    } | {
                        tag: "u16";
                        value: undefined;
                    } | {
                        tag: "u32";
                        value: undefined;
                    } | {
                        tag: "u64";
                        value: undefined;
                    } | {
                        tag: "u128";
                        value: undefined;
                    } | {
                        tag: "u256";
                        value: undefined;
                    } | {
                        tag: "i8";
                        value: undefined;
                    } | {
                        tag: "i16";
                        value: undefined;
                    } | {
                        tag: "i32";
                        value: undefined;
                    } | {
                        tag: "i64";
                        value: undefined;
                    } | {
                        tag: "i128";
                        value: undefined;
                    } | {
                        tag: "i256";
                        value: undefined;
                    };
                } | {
                    tag: "compact";
                    value: number;
                } | {
                    tag: "bitSequence";
                    value: {
                        bitStoreType: number;
                        bitOrderType: number;
                    };
                };
                docs: string[];
            }[];
            pallets: {
                name: string;
                storage: {
                    prefix: string;
                    items: {
                        name: string;
                        modifier: number;
                        type: {
                            tag: "map";
                            value: {
                                hashers: ({
                                    tag: "Blake2128";
                                    value: undefined;
                                } | {
                                    tag: "Blake2256";
                                    value: undefined;
                                } | {
                                    tag: "Blake2128Concat";
                                    value: undefined;
                                } | {
                                    tag: "Twox128";
                                    value: undefined;
                                } | {
                                    tag: "Twox256";
                                    value: undefined;
                                } | {
                                    tag: "Twox64Concat";
                                    value: undefined;
                                } | {
                                    tag: "Identity";
                                    value: undefined;
                                })[];
                                key: number;
                                value: number;
                            };
                        } | {
                            tag: "plain";
                            value: number;
                        };
                        fallback: HexString;
                        docs: string[];
                    }[];
                } | undefined;
                calls: number | undefined;
                events: number | undefined;
                constants: {
                    name: string;
                    type: number;
                    value: HexString;
                    docs: string[];
                }[];
                errors: number | undefined;
                index: number;
                docs: string[];
            }[];
            extrinsic: {
                version: number;
                address: number;
                call: number;
                signature: number;
                extra: number;
                signedExtensions: {
                    identifier: string;
                    type: number;
                    additionalSigned: number;
                }[];
            };
            type: number;
            apis: {
                name: string;
                methods: {
                    name: string;
                    inputs: {
                        name: string;
                        type: number;
                    }[];
                    output: number;
                    docs: string[];
                }[];
                docs: string[];
            }[];
            outerEnums: {
                call: number;
                event: number;
                error: number;
            };
            custom: [string, {
                type: number;
                value: HexString;
            }][];
        };
    };
}>;

declare const Blake2256: (encoded: Uint8Array) => Uint8Array;
declare const Blake2128: (encoded: Uint8Array) => Uint8Array;
declare const Blake2128Concat: (encoded: Uint8Array) => Uint8Array;

declare const Identity: (encoded: Uint8Array) => Uint8Array;

declare const Twox128: (input: Uint8Array) => Uint8Array;
declare const Twox256: (input: Uint8Array) => Uint8Array;
declare const Twox64Concat: (encoded: Uint8Array) => Uint8Array;

declare function h64(input: Uint8Array, seed?: bigint): bigint;

type EncoderWithHash<T> = [Codec<T>, (input: Uint8Array) => Uint8Array];
declare const Storage: (pallet: string) => <T, A extends EncoderWithHash<any>[]>(name: string, dec: Decoder<T>, ...encoders_0: A) => {
    enc: (...args: { [K in keyof A]: A[K] extends EncoderWithHash<infer V> ? V : unknown; }) => string;
    dec: Decoder<T>;
    keyDecoder: (value: string) => { [K_1 in keyof A]: A[K_1] extends EncoderWithHash<infer V_1> ? V_1 : unknown; };
};

type PlainDescriptor<T> = number & {
    _type?: T;
};
type AssetDescriptor<T> = string & {
    _type?: T;
};
type StorageDescriptor<Args extends Array<any>, T, Optional extends true | false> = number & {
    _type: T;
    _args: Args;
    _optional: Optional;
};
type TxDescriptor<Args extends {} | undefined> = number & {
    ___: Args;
};
type RuntimeDescriptor<Args extends Array<any>, T> = number & {
    __: [Args, T];
};
type Descriptors = {
    pallets: Record<string, [
        Record<string, StorageDescriptor<any, any, any>>,
        Record<string, TxDescriptor<any>>,
        Record<string, PlainDescriptor<any>>,
        Record<string, PlainDescriptor<any>>,
        Record<string, PlainDescriptor<any>>
    ]>;
    apis: Record<string, Record<string, RuntimeDescriptor<any, any>>>;
    asset: AssetDescriptor<any>;
    checksums: Promise<string[]>;
};
type PickDescriptors<Idx extends 0 | 1 | 2 | 3 | 4, T extends Descriptors["pallets"]> = {
    [K in keyof T]: T[K][Idx];
};
type ExtractStorage<T extends Record<string, Record<string, StorageDescriptor<any, any, any>>>> = {
    [K in keyof T]: {
        [KK in keyof T[K]]: T[K][KK] extends StorageDescriptor<infer Key, infer Value, infer Optional> ? {
            KeyArgs: Key;
            Value: Value;
            IsOptional: Optional;
        } : unknown;
    };
};
type ExtractTx<T extends Record<string, Record<string, TxDescriptor<any>>>> = {
    [K in keyof T]: {
        [KK in keyof T[K]]: T[K][KK] extends TxDescriptor<infer Args> ? Args : unknown;
    };
};
type ExtractPlain<T extends Record<string, Record<string, PlainDescriptor<any>>>> = {
    [K in keyof T]: {
        [KK in keyof T[K]]: T[K][KK] extends PlainDescriptor<infer Value> ? Value : unknown;
    };
};
type QueryFromDescriptors<T extends Descriptors> = ExtractStorage<PickDescriptors<0, T["pallets"]>>;
type TxFromDescriptors<T extends Descriptors> = ExtractTx<PickDescriptors<1, T["pallets"]>>;
type EventsFromDescriptors<T extends Descriptors> = ExtractPlain<PickDescriptors<2, T["pallets"]>>;
type ErrorsFromDescriptors<T extends Descriptors> = ExtractPlain<PickDescriptors<3, T["pallets"]>>;
type ConstFromDescriptors<T extends Descriptors> = ExtractPlain<PickDescriptors<4, T["pallets"]>>;

type GetEnum<T extends Enum<{
    type: string;
    value: any;
}>> = {
    [K in T["type"]]: (...args: ExtractEnumValue<T, K> extends undefined ? [] : [value: ExtractEnumValue<T, K>]) => T;
};

export { AccountId, type AssetDescriptor, Bin, Binary, type BitSequence, Blake2128, Blake2128Concat, Blake2256, type BlockHeader, type ConstFromDescriptors, type Descriptors, type Discriminant, type EncoderWithHash, Enum, type ErrorsFromDescriptors, type EventsFromDescriptors, type ExtractEnumValue, FixedSizeBinary, type GetEnum, Hex, type HexString, Identity, type PlainDescriptor, type QueryFromDescriptors, type RuntimeDescriptor, type SS58AddressInfo, type SS58String, Self, Storage, type StorageDescriptor, Twox128, Twox256, Twox64Concat, type TxDescriptor, type TxFromDescriptors, type V14Lookup, type V15, type V15Extrinsic, Variant, _Enum, bitSequence, blockHeader, char, compactBn, compactNumber, fixedStr, fromBufferToBase58, getSs58AddressInfo, h64, metadata, selfDecoder, selfEncoder, v15 };
