// This file is part of Cybros.

// Copyright (C) Jun Jiang.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0

// Cybros is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// Cybros is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with Cybros.  If not, see <http://www.gnu.org/licenses/>.

#![cfg_attr(not(feature = "std"), no_std)]

#[cfg(feature = "std")]
use std::fmt;

use scale_codec::{Decode, Encode, MaxEncodedLen};
use scale_info::TypeInfo;
use sp_core::bounded::{BoundedVec, ConstU32, Get};

pub type ImplBuildVersion = u32;
pub type ImplBuildMagicBytes = BoundedVec<u8, ConstU32<64>>;
pub type ImplSpecVersion = u32;

#[derive(Clone, PartialEq, Eq, Encode, Decode, TypeInfo, Debug)]
pub enum OfflineReason {
	Graceful,
	Forced,
	Unresponsive,
	AttestationExpired,
	ImplBuildRetired,
	InsufficientDepositFunds,
	Other,
}

/// The type of how the worker do attestation
#[derive(Clone, PartialEq, Eq, Encode, Decode, TypeInfo, MaxEncodedLen, Debug)]
pub enum AttestationMethod {
	/// Opt out, should only use for dev and testing
	OptOut,
	// TODO: Intel SGX (EPID, ECDSA), AMD SEV, etc.
}

#[derive(Clone, PartialEq, Eq, Encode, Decode, TypeInfo, Debug)]
pub enum AttestationError {
	Invalid,
	Expired,
}

/// Worker's attestation
#[derive(Clone, Eq, PartialEq, Encode, Decode, TypeInfo, MaxEncodedLen, Debug)]
pub enum Attestation {
	OptOut,
	// TODO: Intel SGX DCAP, AMD SEV, etc.
	// TODO: Certificate
}
impl Attestation {
	pub fn verify(&self, _now: u64) -> Result<VerifiedAttestation, AttestationError> {
		match self {
			Attestation::OptOut => Ok(VerifiedAttestation(self)),
		}
	}

	pub fn method(&self) -> AttestationMethod {
		match self {
			Attestation::OptOut => AttestationMethod::OptOut,
		}
	}

	pub(self) fn payload(&self) -> Option<&[u8]> {
		match self {
			Attestation::OptOut => None,
		}
	}

	pub(self) fn expires_at(&self) -> Option<u64> {
		match self {
			Attestation::OptOut => None,
		}
	}
}

#[derive(Clone, PartialEq, Debug)]
pub struct VerifiedAttestation<'a>(&'a Attestation);
impl VerifiedAttestation<'_> {
	pub fn method(&self) -> AttestationMethod {
		self.0.method()
	}

	pub fn payload(&self) -> Option<&[u8]> {
		self.0.payload()
	}

	pub fn expires_at(&self) -> Option<u64> {
		self.0.expires_at()
	}
}

#[derive(Clone, PartialEq, Eq, Encode, Decode, TypeInfo, MaxEncodedLen, Debug)]
pub struct OnlinePayload<ImplId> {
	pub impl_id: ImplId,
	pub impl_spec_version: ImplBuildVersion,
	pub impl_build_version: ImplBuildVersion,
	pub impl_build_magic_bytes: ImplBuildMagicBytes,
}

/// Worker's status
#[derive(
	Copy, Clone, PartialEq, Eq, Encode, Decode, TypeInfo, MaxEncodedLen, Debug, Default,
)]
pub enum WorkerStatus {
	/// Initial status for a new registered worker.
	#[default]
	Registered,
	/// The worker is online so it can accept job
	/// Transit from `Registered` and `Offline`, and `Unresponsive`
	/// not sure for `RequestingOffline` (may have side effect)
	Online,
	/// The worker isn't send heartbeat on time
	/// Transit from `Online`
	Unresponsive,
	/// The worker is requesting offline,
	/// the worker won't accept new job, accepted jobs will still processing,
	/// when accepted jobs processed it can be transited to `Offline` safely without slashing.
	/// Transit from `Online`
	RequestingOffline,
	/// The worker is offline so it can't accept job.
	/// Transit from `RequestingOffline` when job queue cleared,
	/// and `Online` (when force by user or be slashed) and `Unresponsive`
	Offline,
}

#[cfg(feature = "std")]
impl fmt::Display for WorkerStatus {
	fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
		match self {
			WorkerStatus::Registered => write!(f, "Registered"),
			WorkerStatus::Online => write!(f, "Online"),
			WorkerStatus::Unresponsive => write!(f, "Unresponsive"),
			WorkerStatus::RequestingOffline => write!(f, "RequestingOffline"),
			WorkerStatus::Offline => write!(f, "Offline"),
		}
	}
}

/// Worker's info.
#[derive(Clone, Encode, Decode, MaxEncodedLen, TypeInfo, Debug)]
pub struct WorkerInfo<AccountId, Balance, ImplId> {
	/// Account that generated by the worker app, used for identity the worker and send extrinsic.
	/// This field is readonly once set
	pub account: AccountId,
	/// Account that owning the worker.
	/// This field is readonly once set
	pub owner: AccountId,
	/// Reserved balance on register.
	/// This field is readonly once set
	pub deposit: Balance,
	/// Status
	pub status: WorkerStatus,
	/// The registered implementation's id
	/// This field is readonly once set
	pub impl_id: ImplId,
	/// Bump when the implementation has major change
	pub impl_spec_version: Option<ImplSpecVersion>,
	/// Version of the implementation, this is help to distinguish different implementations,
	/// It can not be the public version exposed to end users.
	pub impl_build_version: Option<ImplBuildVersion>,
	/// Attestation method,
	/// This field is readonly once set
	pub attestation_method: Option<AttestationMethod>,
	pub attestation_expires_at: Option<u64>,
	/// A block number of when the worker refresh its attestation.
	pub attested_at: Option<u64>,
	pub last_sent_heartbeat_at: Option<u64>,
	pub uptime_started_at: Option<u64>,
	pub uptime: Option<u64>,
}

#[derive(
	Copy, Clone, PartialEq, Eq, Encode, Decode, MaxEncodedLen, TypeInfo, Debug, Default,
)]
pub enum FlipFlopStage {
	#[default]
	Flip,
	Flop,
	FlipToFlop,
	FlopToFlip,
}

/// Information about an implementation.
#[derive(Clone, Encode, Decode, Eq, PartialEq, Debug, TypeInfo, MaxEncodedLen)]
pub struct ImplInfo<ImplId, AccountId, Balance> {
	/// Implementation's id
	pub id: ImplId,
	/// Implementation's owner.
	pub owner: AccountId,
	/// The total balance deposited by the owner for all the storage data associated with this
	/// pool. Used by `destroy`.
	pub owner_deposit: Balance,
	/// The implementation must specify use which attestation method,
	pub attestation_method: AttestationMethod,
	/// The total number of outstanding workers running this implementation.
	pub workers_count: u32,
}

#[derive(Copy, Clone, PartialEq, Eq, Encode, Decode, TypeInfo, MaxEncodedLen, Debug)]
pub enum ImplBuildStatus {
	Released,
	/// Deprecated will forbid new workers online with this build
	Deprecated,
	/// Blocked will forbid workers online, and heartbeat, so they have to upgrade
	Retired,
}

#[derive(Clone, Encode, Decode, Eq, PartialEq, Debug, TypeInfo, MaxEncodedLen)]
pub struct ImplBuildInfo {
	pub version: ImplBuildVersion,
	pub magic_bytes: Option<ImplBuildMagicBytes>,
	pub status: ImplBuildStatus,
	/// The total number of outstanding workers running this build.
	pub workers_count: u32,
}

/// Generic data that stored on-chain
#[derive(Clone, Encode, Decode, Eq, PartialEq, Debug, Default, TypeInfo, MaxEncodedLen)]
#[scale_info(skip_type_params(DataLimit))]
#[codec(mel_bound(AccountId: MaxEncodedLen, Balance: MaxEncodedLen))]
pub struct ChainStoredData<AccountId, Balance, DataLimit: Get<u32>> {
	/// The depositor
	pub depositor: AccountId,
	/// The balance deposited for this data.
	///
	/// This pays for the data stored in this struct.
	pub actual_deposit: Balance,
	pub surplus_deposit: Balance,
	/// General information concerning this collection. Limited in length by `StringLimit`. This
	/// will generally be either a JSON dump or the hash of some JSON which can be found on a
	/// hash-addressable global publication system such as IPFS.
	pub data: BoundedVec<u8, DataLimit>,
}
